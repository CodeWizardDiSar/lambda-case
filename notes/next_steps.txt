scope:
- remove head when leaving scope: where?

type inference:
- many arguments application:
  - infer function
  - type check with the abstraction types 
  - remaining = result type

type abstractions:
- ==>, <==, *==>, paren at the end (mathematical notation):
  - it's just application for types
  - many different parsers for type lambda abstractions
  - Single Capital Letter:
    - maybe need to prevent using that as an actual type

fix:
- cases at the end of one argument applications:
  optionMaybe or change the last type??
- "use fields" in parenthesis and tuples
- let-output -> where:
  - problem with values in and outside of function
  - add intentation levels in parsing
- many abstractions in tuple ? I meant arguments ?

cases:
- "value" default name for the value of each case that has a value:
  - use "...C value@(...)" in tuple_type cases
  - use "...C value" in or_type cases
  - use "...C" no value cases
- add "..." case functionality:
  - only use "value -> " in last case
  - create new type LOVNOrDefault
  - LOVN LiterOrValueName | Default
  - parse "..." to Default:
    optionMaybe?
- check cases for or_type

literals:
- reals + strings:
  - string: char '"' *> many (noneOf ['"']) <* char '"'
  - real: I think I have it bookmarked in the browser somewhere

autogenerated functions:
- update_field: TupleType, FieldType *-> TupleType
  put in map + generate definition
- is_case: OrType -> Bool
  put in map + generate definition

operators:
- o>, <o 
- type class maybe? 

parentheses in the middle:
- function definition
- function application

better error:
- transform the state with EitherT (or ExceptT)
- find error calls that are errors for the user and modify them appropriately
- add line/column numbers

type predicates
type theorems
my default show
comments
undefined keyword

testing:
- wrong examples 
