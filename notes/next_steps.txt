type abstractions:
- ==>, <==, *==>, paren at the end (mathematical notation)

fix:
- generate constructors for tuple_type tuple values 
- cases/use_fields at the end of one argument applications:
  optionMaybe!
- stack of types in value map for multiple-level definitions
- let-output -> where 
  - problem with values in and outside of function:
    add intentation levels in parsing
- one argument application:
  - change type to binary tree of base values?

cases:
- "value" default name for tuple_type value of each case:
  - name default case value in Haskell
  - use haskell @ operator everywhere
- add "..." case functionality:
  - create new type LOVNOrDefault
  - LOVN LiterOrValueName | Default
  - parse "..." to Default:
    optionMaybe?

use_fields:
- "value" default name for the whole tuple_type value

literals:
- reals + strings

autogenerated functions:
- update_field: TupleType, FieldType *-> TupleType
  - put in map + generate definition
- is_case: OrType -> Bool
  - put in map + generate definition

regular parenthesis function application:
- parser for already existing type?

operators:
- o>, <o 
- type class maybe? 

parentheses in the middle:
- function definition
- function application

better error:
- transform the state with EitherT (or ExceptT)
- find error calls that are errors for the user and modify them appropriately
- add line/column numbers

testing:
- wrong examples 
