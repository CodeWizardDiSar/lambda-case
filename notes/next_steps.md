scope:
- remove head when leaving scope: where?

type abstractions:
- ==>, <==, *==>, parenthesis at the end (mathematical notation):
  - Create new source type for type constructors
  - type abstractions:
    - many different parsers for type inputs/lambda abstractions
  - type application

fix:
- *==> in parenthesis (x, y *==> gcd_help) problem with tuple:
  - eliminate parenthesis??
- cases at the end of one argument applications:
  optionMaybe or change the last type??
- "use_fields" in parenthesis and tuples:
  - need to change from output_value to operator_value
- let-output -> where:
  - problem with values in and outside of function
  - add intentation levels in parsing
- many abstractions in tuple ? I meant arguments ?
- split value type into function and constant types ?
- load "get_first" only when needed
- change types to recursive instead of lists ?

cases:
- "value" default for the value of each case that has a value:
  - use "...C value@(...)" in tuple_type cases
  - use "...C value" in or_type cases
  - use "...C" no value cases
- add "..." case functionality:
  - only use "value -> " in last case
  - create new type (not really sure if needed):
    data LOVNOrDefault =
      LOVN LiteralOrValueName | Default
  - parse "..." to Default:
    optionMaybe?
- check cases for or_type

literals:
- reals + strings:
  - string: char '"' *> many (noneOf ['"']) <* char '"'
  - real: I think I have it bookmarked in the browser somewhere

autogenerated functions:
- update_field: TupleType, FieldType *-> TupleType
  put in map + generate definition
- is_case: OrType -> Bool
  put in map + generate definition

operators:
- o>, <o 
- type class maybe? 

parentheses in the middle:
- function definition
- function application

better error:
- transform the state with EitherT (or ExceptT)
- find error calls that are errors for the user and modify them appropriately
- add line/column numbers

type predicates
type theorems
my default show
comments
undefined

testing:
- more right examples
- wrong examples 

change?:
- A, A *-> A ===> A x A -> A
