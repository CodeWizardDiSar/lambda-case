
tuple_type (T1)Tree
value (root, subtrees) : T1 x (T1)Trees

type_nickname (T1)Trees = MyListOf((T1)Tree)s

or_type MyListOf(T1)s
values non_empty_l:NonEmptyListOf(T1)s | empty_l

tuple_type NonEmptyListOf(T1)s
value (head, tail) : T1 x MyListOf(T1)s

tuple_type (T1)ResultTreeAndNum
value (tree, t_num) : (Int x T1)Tree x Int

tuple_type (T1)ResultTreesAndNum
value (trees, ts_num) : (Int x T1)Trees x Int

dfs_on_tree(_) : (T1)Tree => (Int x T1)Tree
  = dfs_on_tree(_)with_num(1) o> _.tree
    where
    dfs_on_tree(_)with_num(_) : (T1)Tree x Int => (T1)ResultTreeAndNum
      = (tree, num) => (new_tree, subtrees_res.ts_num)
        where
        new_tree : (Int x T1)Tree
          = ((num, tree.root), subtrees_res.trees)

        subtrees_res : (T1)ResultTreesAndNum
          = dfs_on_subtrees(tree.subtrees)with_num(num + 1)

    dfs_on_subtrees(_)with_num(_) : (T1)Trees x Int => (T1)ResultTreesAndNum
      = (cases, num)
        empty_l => (empty_l, num)
        non_empty_l:subtrees =>
          (non_empty_l:(tree1, other_trees), subtrees_res.ts_num)
          where
          tree1 : (Int x T1)Tree
            = first_tree_res.tree

          first_tree_res : (T1)ResultTreeAndNum
            = dfs_on_tree(subtrees.head)with_num(num)

          other_trees : (Int x T1)Trees
            = subtrees_res.trees

          subtrees_res : (T1)ResultTreesAndNum
            = dfs_on_subtrees(subtrees.tail)with_num(first_tree_res.t_num)

test_tree : (Char)Tree
  = ('a', non_empty_l:(t1, non_empty_l:(t2, non_empty_l:(t3, empty_l))))
    where
    t1 : (Char)Tree
      = ('b', non_empty_l:(('e', empty_l), non_empty_l:(('f', empty_l), empty_l)))

    t2 : (Char)Tree
      = ('c', empty_l)

    t3 : (Char)Tree
      = ('d', non_empty_l:(('g', empty_l), non_empty_l:(('h', empty_l), empty_l)))

type_proposition (@T)Has_String_Repr
needed (_)to_string : @T => String

type_theorem (Int x Char)Has_String_Repr
proof (_)to_string = show

type_theorem (@A)Has_String_Repr --> (MyListOf(@A)s)Has_String_Repr
proof
  (_)to_string =
    cases
      empty_l => ""
      non_empty_l:(head, tail) => (head)to_string + ", " + (tail)to_string

type_theorem ((Int x Char)Tree)Has_String_Repr
proof
  (_)to_string =
    (root, subtress) =>
    "root: " + (root)to_string + "\nsubtrees: " + (subtrees)to_string + "\n"

main: IO
  = (my_int_list)to_string -> print_line(_)
