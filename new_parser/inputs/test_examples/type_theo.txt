type_theorem (Possibly(_))Has_A_Wrapper
proof wrap(_) = the_value:_#

type_theorem (ListOf(_)s)Has_A_Wrapper
proof wrap(_) = [_]#

type_theorem (Possibly(_))Has_Internal_App
proof
  apply(_)inside(_) =
    (f, cases)
      no_value => no_value
      the_value:the_value:x =>
        the_value:f(x)
        where
        x : Int
          = 1#

type_theorem (ListOf(_)s)Has_Internal_App
proof
  apply(_)inside(_) =
    (f, cases)
      empty_l => empty_l
      non_empty_l:l => non_empty_l:(f(l.head), apply(f)inside(l.tail))#

type_theorem (@A)And(@B)Can_Be_Equal --> (@A)And(@B)Can_Be_Unequal
proof a != b = not(a == b)#

type_theorem (@A)Can_Be_Greater_Than(@B) --> (@A)Can_Be_Le_Or_Eq_To(@B)
proof a <= b = not(a > b)#

type_theorem (@A)And(@B)Have_Eq_And_Gr --> (@A)Can_Be_Gr_Or_Eq_To(@B)
proof a >= b = a == b | a > b#

type_theorem (Possibly(_))Has_A_Wrapper
proof
  wrap(_) = the_value:_#

type_theorem (ListOf(_)s)Has_A_Wrapper
proof
  wrap(_) =
    [_]#

type_theorem (ListOf(_)s)Has_A_Wrapper
proof
  wrap(_) =
    a
    where
    a : Int
      = b#

type_theorem (ListOf(T1)s)And(T1)add_to(ListOf(T1)s)
proof
  l + a =
    l -> cases
      empty_l => non_empty_l:(a, empty_l)
      non_empty_l:(head, tail) => non_empty_l:(head, tail + a)#

type_theorem (ListOf(T1)s)And(T1)add_to(ListOf(T1)s)
proof
  l + a =
    l -> a#

