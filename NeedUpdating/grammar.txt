Grammar 

<program> ::=
  [ <imports> ] ( <type_definition> )* ( <type_predicate> )* ( <type_proposition> )*
  ( <value> )+

<imports> ::= "import" ( "\n\t" <imported_functions> "\n\t\tfrom " <library> )+
<imported_functions> ::= <id> ( ", " <id> )*
<library> ::= <id>

<type_definition> ::= <tuple_type_definition> | <multiple_constructors_type_definition>

<tuple_type_definition> ::= "tuple_type " <type_name> "\nvalue\n" <tuple_constructor>
<tuple_constructor> ::= "\t" <constructor_name> "\n" ( <constructor_input> )* "\n"
<constructor_input> ::= "\t\t" <input_name> " : " <input_type> "\n"
<input_name> ::= <capital_first_id>

<multiple_constructors_type_definition> ::=
  "type " <type_name> "\nvalues\n" <constructor> ( <constructor> )+ "\n"
<constructor> ::= "\t" <constructor_name> ( " " <input_type> )* "\n"
// only if <= 4 inputs

<type_name> ::=
  <capital_first_id> | <parenthesis_application_name> | <no_parenthesis_application_name>
<parenthesis_application_name> ::=
  ( <capital_first_id> "(" <type_variables> ")" )+ |
  ( "(" <type_variables> ")" <capital_first_id> )+
<no_parenthesis_application_name> ::= <capital_first_id> ( " " <type_variable> )*

<type_variables> ::= <type_variable> ( ", " <type_variable> )*
<type_variable> ::= <capital_first_id>
<constructor_name> ::= <capital_first_id>
<input_type> ::= <capital_first_id>

<value> ::= <type_expression> "\n" <value_name> " = " <value_expression> "\n\n"
<type_expression> ::= [ <type_predicate> " => " ] <type>
<value_name> ::= <id>
<value_expression> ::=
  <constant> | <value_name> | <constructor_name> | <application>
             | <first_input_naming> | <case_matching> | "(" <value_expression> ")"

<application> ::= <value_expression> <value_expression>

<type> ::= <type_name> ( " -> " <type_name> )*

<first_input_naming> ::= <input_id> "->" <value_expression>
<input_id> ::= <id>

<case_matching> ::= "case\n" ( <match> )+

<match> ::=
  "\t" <constructor_name> ( " " ( <value_name> | <constant> ) )* " -> " <value_expression>

<type_predicate> ::=
  "type_predicate " <predicate_name> "\nrequired\n" ( <required> )+

<predicate_name> ::= ( <capital_first_id> ( "(" <type_variables> ")" ) )+

<required> ::= "\t" <value_name> " : " <type> "\n"

<type_proposition> ::=
  "type_proposition " <predicate_instance> "\nproof\n" ( <required_definition> )+

<predicate_instance>  ::= ( <capital_first_id> | ( "(" <type_name> ")" ) )+

<required_definition> ::= "\t" <value_name> " = " <value_expression>

application left associative
