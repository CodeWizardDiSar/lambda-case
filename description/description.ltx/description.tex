\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{syntax}
\usepackage{array}
\usepackage{multirow}
\usepackage[left=2cm,right=2cm,top=2cm]{geometry}

\date{}
\author{
  Dimitris Saridakis
}

\def\imgs{../Images}
\def\H{Haskell}
\def\ra{\texttt{=>}\ }
\def\Ra{\texttt{-->}\ }
\def\pend{\mbox{} \\\\}
%\newcommand\_[_]{_}

\renewcommand{\arraystretch}{1.5}

\begin{document}

\title{
\textbf{Lambda Cases (lcases)}
}
\maketitle

%\setcounter{tocdepth}{4}
%\setcounter{secnumdepth}{4}
\tableofcontents

\section{Introduction}

\H\ is a delightful language. Yet, for some reason, it doesn't seem to have
it's rightful place in terms of popularity in industry. Why is it so?  Is it
inherently hard to learn and therefore only the brave dare to use it, or could
it be that the syntax is perplexing to the amateur eye? It is my belief that
with some syntax changes that give a greater familiarity to the new user, there
would be no language more compelling than (the new) \H. In an attempt to
achieve that familiarity, I present some (hopefully useful) new syntax, of
which some is closer to the imperative/OOP style (to attract more already
experienced programmers from these languages), some is closer to mathematics
(in which most programmers should be experienced) and some is closer to natural
language (in which we are all already experienced). 

\section{Language Description}

An lcases program consists of a set of definitions and theorems.  Definitions
are split into value definitions, type definitions, type predicate definitions
and type proposition definitions. Theorems are proven type propositions.  The
definition of the "main" value determines the program's behaviour.  Constants
and functions are all considered values and they have no real distinction other
than the fact that functions have a function type and constants don't.
Functions (just like "values") can be passed to other functions as arguments or
can be returned as a result of other functions. 

\paragraph{Program example: extended euclidean alogirthm}
\begin{verbatim}
// type definitions

tuple_type Coeffs
value (previous, current) : Int x Int

tuple_type GcdAndCoeffs
value (gcd, a, b) : Int x Int x Int

// algorithm

init_a_coeffs, init_b_coeffs: all Coeffs
  = (1, 0), (0, 1)

ext_euc: (Int, Int) => GcdAndCoeffs
  = ext_euc_rec(init_a_coeffs, init_b_coeffs)

ext_euc_rec: (Coeffs, Coeffs, Int, Int) => GcdAndCoeffs
  = (a_coeffs, b_coeffs, x, cases) =>
    0 => (x, a_coeffs.previous, b_coeffs.previous)
    y => ext_euc_rec(next <- a_coeffs, next <- b_coeffs, y, x -> mod <- y)
      where
      next: Coeffs => Coeffs
        = fields => (current, previous - x / y * current)

// reading, printing and main

read_two_ints : (Int x Int)IOAction
  = print <- "Please give me 2 ints";
    get_line ;> split_words o> apply(from_string)to_all o> ints =>
    ints -> length -> cases =>
      2 => ints -> with_io
      ... => io_error <- "You didn't give me 2 ints"
 
print_gcd_equation : (Int, Int, GcdAndCoeffs) => (EmptyValue)IOAction
  = (x, y, fields) => print("gcd = " + gcd + " = " + sum_string)
    where
    sum_string : String
      = a + " * " + x + " + " + b + " * " + y

main : (EmptyValue)IOAction
  = read_two_ints ;> ints =>
    print_gcd_and_coeffs(ints.1st, ints.2nd, ext_euc(ints.1st, ints.2nd))
\end{verbatim}

\subsection{Keywords}

The lcases keywords are the following:
\begin{verbatim}
fields cases where all tuple_type value or_type values
type_pred function type_prop equiv type_theo proof
\end{verbatim}
Each keyword's funtionality is described in the respective section shown in the 
table below:

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Keyword & Section \\ 
\hline
\hline
\texttt{fields cases} & \ref{subsec:funcexprs} Function Expressions \\
\hline
\texttt{where all} & \ref{subsec:valdefswhere} Value Definitions \\
\hline
\texttt{tuple_type value or_type values} & \ref{subsec:types} Types \\
\hline
\texttt{type_pred function type_prop equiv type_theo proof} &
  \ref{subsec:typelogic} Type Logic \\
\hline
\end{tabular}
\end{center}
The "\texttt{fields}", "\texttt{cases}" and "\texttt{where}" keywords are also
reserved words. Therefore, even though they can be generated by the
"identifiers" grammar, they cannot be used as identifiers (see "Literals and
Identifiers" section \ref{subsubsec:litsandidents}).

\subsection{Basic Value Expressions}

\subsubsection{Literals and Identifiers}
\label{subsubsec:litsandidents}

\paragraph{Literals}
\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
1  2  17  42  -100
1.61  2.71  3.14  -1234.567
'a'  'b'  'c'  'x'  'y'  'z'  '.'  ','  '\n'
"Hello World!"  "What's up, doc?"  "Alrighty then!"
\end{verbatim}

\item \textit{Description} \\\\
We have literals for the four basic types: Int, Real, Char, String. These are the 
usual integers, real numbes, characters and strings. The exact specification of 
literals is the same as in the \H\ report.

\item \textit{Grammar}
\begin{grammar}
<literal> ::= <literal>
\end{grammar}
TODO add the grammar from the haskell report

\end{itemize}


\paragraph{Identifiers}
\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
x y z
a1 a2 a3 
funny_identifier 
unnecessarily_long_identifier
apply()to_all
\end{verbatim}

\item \textit{Description} \\\\
An identifier is a string used as the name of a value. It is first used in the
definition of the value (see "value definition" section \ref{subsec:valdefswhere})
and later used in the definition of other values that use that defined value.
An identifier starts with a lower case letter and is followed by lower case
letters or underscores. It is also possible to have pairs of parentheses in the
middle of an identifier (see "parenthesis function application" section
\ref{subsec:parenfuncapp} for why this can be useful). Finally, an identifier
can be ended with a digit.

\item \textit{Grammar}
\begin{grammar}
<identifier> ::= [a-z]( [a-z_] | `()'[a-z_] )* [ [0-9] ]
\end{grammar}
Even though the "\texttt{fields}", "\texttt{cases}" and "\texttt{where}"
keywords can be generated by this grammar, they cannot be used as identifiers.

\end{itemize}

\newpage
\subsubsection{Parenthesis, Tuples and Lists}

\paragraph{Parenthesis}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
(1 + 2)
in
(1 + 2) * 3

(x => f(x) + 1) and (s => "f(val) + 1 is: " + s)
in
val -> (x => f(x) + 1) -> to_string -> (s => "f(val) + 1 is: " + s)

("Line is: " + line) and (get_line ;> line => print("Line is: " + line))
in
do(3)times <- (get_line ;> line => print("Line is: " + line))
\end{verbatim}

\item \textit{Description} \\\\
An expression is put in parenthesis to prioritize it or isolate it in a bigger
(operator) expression. The expressions inside parethesis are operator
or function expressions.

\item \textit{Grammar}
\begin{grammar}
<paren-expr> ::= `(' <one-line-expr> `)' 

<one-line-expr> ::= <one-line-op-expr> | <one-line-func-expr>\\
\end{grammar}

\end{itemize}

\paragraph{Tuples}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
(1, "What's up, doc?")
(2, "Alrighty then!", 3.14)
(x, y, z, w)
(1, my_function, (x, y, z) => (x ^ 2 + y ^ 2 + z ^ 2) ^ (1/2))
\end{verbatim}

\item \textit{Description} \\\\
Tuples are used to group many values (of possibly different types) into one.
The type of the tuple can be either the product of the types of the subvalues or a
defined tuple\_type which is equivalent to the afformentioned product type i.e.
the product type is in the definition of the tuple\_type (see "tuple\_type"
section \ref{subsubsec:tupts}). For example, the type of the second example above 
could be:
\begin{verbatim}
Int x String x Real
\end{verbatim}
or:
\begin{verbatim}
MyType
\end{verbatim}
assuming "MyType" has been defined in a similar way to the following:
\begin{verbatim}
tuple_type MyType
value (my_int, my_string, my_real) : Int x String x Real
\end{verbatim}

\item \textit{Indentation Rules} \\\\
It is possible to stretch a (big) tuple expression over multiple lines, only in a
seperate value definition (see "Value Definitions" \ref{subsubsec:valdefs}).
In that case:
\begin{itemize}
\item
The character '(' is after the "= " part of the value definition
and the first subvalue must be in the same line.

\item
The tuple can split in a new line only at a ',' character. Every such line must
be indented so that the ',' is in same column where the '(' character was in
the first line.

\item
The tuple must be ended by a line that only contains the ')' character and is 
also indented so that the ')' is in same column where the '(' character was in
the first line.

\item
The precise indentation rules are described in detail in the section
"Indentation System" \ref{subsubsec:indsys}.
\end{itemize}
Example:
\begin{verbatim}
my_big_tuple : String x Int x Real x String x String x (String x Real x Real)
  = ( "Hey, I'm the first subvalue and I'm also a relatively big string."
    , 42, 3.14, "Hey, I'm the first small string", "Hey, I'm the second small string"
    , ("Hey, I'm a string inside the nested tuple", 2.71, 1.61)
    )
\end{verbatim}

\item \textit{Grammar}
\begin{grammar}
<tuple> ::= `(' <basic-or-one-line-expr> `,\ ' <comma-sep-exprs> `)'

<comma-sep-exprs> ::=
<basic-or-one-line-expr> ( `,\ ' <basic-or-one-line-expr> )*

<basic-or-one-line-expr> := <basic-expr> | <one-line-expr>

<basic-expr> ::=
<literal> | <identifier> | <tuple> | <list> | <paren-func-app>\\

<stretched-tuple> ::= ""\\
`(' <basic-or-one-line-expr> [ `\\n' <indentation> ] `,\ ' <comma-sep-exprs> \\
( `\\n' <indentation> `,' <comma-sep-exprs> )* \\
`\\n' <indentation> `)'
\end{grammar}

\end{itemize}

\paragraph{Lists}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
[1, 2, 17, 42, -100]
[1.61, 2.71, 3.14, -1234.567]
["Hello World!", "What's up, doc?", "Alrighty then!"]
[x => x + 1, x => x + 2, x => x + 3]
[x, y, z, w]
\end{verbatim}

\item \textit{Description} \\\\
Lists are used to group many values of the same type into one. 
The type of the list is ListOf(A)s where A is the type of every value inside.
Therefore, the types of the first four examples are:
\begin{verbatim}
ListOf(Int)s
ListOf(Real)s
ListOf(String)s
(A)And(Int)AddTo(B) --> ListOf(A => B)s
\end{verbatim}
And the last list is only legal if x, y, z and w all have the same type. Assuming 
they do and it's the type T, the type of the list is: 
\begin{verbatim}
ListOf(T)s
\end{verbatim}

\item \textit{Indentation Rules} \\\\
It is possible to stretch a (big) list expression over multiple lines, only in a
seperate value definition (see "Value Definitions" \ref{subsubsec:valdefs}).
In that case:
\begin{itemize}
\item
The character '[' is after the "= " part of the value definition
and the first element must be in the same line.

\item
The list can split in a new line only at a ',' character. Every such line must
be indented so that the ',' is in same column where the '[' character was in
the first line.

\item
The tuple must be ended by a line that only contains the ']' character and is 
also indented so that the ']' is in same column where the '[' character was in
the first line.

\item
The precise indentation rules are described in detail in the section
"Indentation System" \ref{subsubsec:indsys}.
\end{itemize}
Example:
\begin{verbatim}
my_big_list : ListOf(Int => (EmptyValue)IOAction)s
  = [ x => print("I'm the first function and x + 1 is: " + (x + 1))
    , x => print("I'm the second function and x + 2 is: " + (x + 2))
    , x => print("I'm the third function and x + 3 is: " + (x + 3))
    ]
\end{verbatim}

\item \textit{Grammar}
\begin{grammar}
<list> ::= `[' [ <comma-sep-exprs> ] `]'

<stretched-list> ::= ""\\
`[' <comma-sep-exprs>
( `\\n' <indentation> `,' <comma-sep-exprs> )*
`\\n' <indentation> `]'
\end{grammar}

\end{itemize}

\subsubsection{Parenthesis Function Application}
\label{subsec:parenfuncapp}

\begin{itemize}
\item \textit{Examples}

\begin{verbatim}
f(x)
f(x, y, z)
(x)to_string
apply(f)to_all
apply(f)to_all(l)
\end{verbatim}

\item \textit{Description}
\\\\
Function application in lcases can be done in many different ways in an attempt to 
maximize readability. In this section, we discuss the ways function application can
be done with parenthesis.
\\\\
In the first two examples, we have the usual mathematical
function application which is also used in most programming languages and
should be familiar to the reader. That is, function application is done with the 
arguments of the function in parenthesis seperated by commas and \textbf{appended}
to the function identifier.
\\\\
We extend this idea by allowing the arguments to be \textbf{prepended} to the
function identifier (third example). Finally, it is also possible to to have
the arguments \textbf{inside} the function identifier provided the function has
been \textbf{defined with parentheses inside the identifier}. For example,
below is the definition of "apply()to\_all":

\begin{verbatim}
apply()to_all: (A => B, ListOf(A)s) => ListOf(B)s
  = (f, cases) =>
    empty => empty
    non_empty:l => non_empty:(f <- l.head, apply(f)to_all <- l.tail)
\end{verbatim}
The actual definition doesn't matter at this point, what matters is that the 
identifier is "apply()to\_all" with the parentheses \textbf{included}. This is very
useful for defining functions where the argument in the middle makes the function
application look and sound more like natural language.
\\\\
In is possible that many paratheses pairs are present in a single function
application (last example). The arguments are always inserted to the function
from \textbf{left to right}.  Therefore, when multiple parentheses pairs are
present the arguments of the leftmost parentheses are inserted first then the
next ones to the right and so on.

\item \textit{Grammar}
\begin{grammar}
<paren-func-app> ::= ""\\
<arguments> ( <identifier-with-arguments> | <identifier> ) [ <arguments> ]
\alt <identifier-with-arguments> [ <arguments> ]
\alt <identifier> <arguments>

<arguments> ::= `(' <comma-sep-exprs> `)'

<identifier-with-arguments> ::= ""\\""
[a-z] <id-char-or-paren-id-char>* ( <arguments> [a-z_]
<id-char-or-paren-id-char>* )+ [ [0-9] ]

<id-char-or-paren-id-char> ::= [a-z_] | `()'[a-z_]
\end{grammar}

\end{itemize}

\subsection{Value Operators}

\subsubsection{Function Application Operators}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{->} & (A, A \ra B) \ra B \\
\hline
\texttt{<-} & (A \ra B, A) \ra B \\
\hline
\end{tabular}
\end{center}
The function application operators "\texttt{->}" and "\texttt{<-}" are a
different way to apply functions to arguments than the usual parenthesis
function application.  They are meant to look like arrows that point from the
argument to the function.  These operators are very useful for chaining many
function applications without the clutter of having to open and close
parentheses for each one of the functions.  For example, assuming we have the
following functions with the behaviour suggested by their names and types:
\begin{verbatim}
apply()to_all : (A => B, ListOf(A)s) => ListOf(B)s
string_length: String => Int
filter_with : (A => Bool, ListOf(A)s) => ListOf(A)s
is_odd : Int => Bool
sum_ints : ListOf(Int)s => Int
\end{verbatim}
And a list of strings:
\begin{verbatim}
strings : ListOf(String)s
\end{verbatim}
Here is a line way to get the number of characters in all the strings that have 
odd length:
\begin{verbatim}
chars_in_odd_length_strings : Int
  = strings -> apply(string_length)to_all -> filter_with(is_odd) -> sum_ints
\end{verbatim}
Ofcourse this can be done equivalently using the other operator:
\begin{verbatim}
chars_in_odd_length_strings : Int
  = sum_ints <- filter_with(is_odd) <- apply(string_length)to_all <- strings

\end{verbatim}
These operators can also be used together to put a function between two arguments
if that function is commonly used that way in math (or if it looks better for a
certain function). For example the "mod" function can be used like so:
\begin{center}
\texttt{x -> mod <- y}
\end{center}
Instead of:
\begin{center}
\texttt{mod(x, y)}
\end{center}

\subsubsection{Function Composition Operators}
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{o>} & (A \ra B, B \ra C) \ra (A \ra C) \\
\hline
\texttt{<o} & (B \ra C, A \ra B) \ra (A \ra C) \\
\hline
\end{tabular}
\end{center}
The function composition operators "\texttt{o>}" and "\texttt{<o}" are used to 
compose functions, each one in the corresponding direction. The use of the letter 'o'
is meant to be similar to the mathematical function composition symbol '\(\circ\)'
and the symbols '\texttt{>}', '\texttt{<}' are used so that the operator points from
the function which is applied first to the function which is applied second.
A neat example using function composition is the following. Assuming we have the
following functions with the behaviour suggested by their names and types: 
\begin{verbatim}
split_words : String => ListOf(String)s
apply()to_all : (A => B, ListOf(A)s) => ListOf(B)s
reverse_string: String => String
merge_words : ListOf(String)s => String
\end{verbatim}
We can reverse the all the words in a string like so:
\begin{verbatim}
reverse_words : String => String
  = split_words o> apply(reverse_string)to_all o> merge_words
\end{verbatim}
Ofcourse this can be done equivalently using the other operator:
\begin{verbatim}
reverse_words : String => String
  = merge_words <o apply(reverse_string)to_all <o split_words
\end{verbatim}


\subsubsection{Arithmetic Operators}
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{\^} & (A)ToThe(B)Gives(C) \Ra (A, B) \ra C \\
\hline
\texttt{*} & (A)And(B)MultiplyTo(C) \Ra (A, B) \ra C \\
\hline
\texttt{/} & (A)Divides(B)To(C) \Ra (B, A) \ra C \\
\hline
+ & (A)And(B)AddTo(C) \Ra (A, B) \ra C \\ 
\hline
- & (A)SubtractsFrom(B)To(C) \Ra (B, A) \ra C \\
\hline
\end{tabular}
\end{center}
The usual arithmetic operators work as they are expected, similarly to
mathematics and other programming languages for the usual types. However, they
are generalized. The examples below show their generality:
\begin{verbatim}
>> 1 + 1
2
>> 1 + 3.14
4.14
>> 'a' + 'b'
"ab"
>> 'w' + "ord"
"word"
>> "Hello " + "World!"
"Hello World!"
>> 5 * 'a'
"aaaaa"
>> 5 * "hi"
"hihihihihi"
>> "1,2,3" - ','
"123"
\end{verbatim}
Let's analyze further the example of addition. The type can be read as such:
the '+' operator has the type \\ (A, B) \ra C, provided that the type
proposition (A)And(B)AddTo(C) holds. This proposition being true, means that
addition has been defined for these three types (see section "type logic"
\ref{subsec:typelogic} for more on type propositions). For example, by the examples
above we can deduce that the following propositions are true (in the order of the 
examples):
\begin{verbatim}
(Int)And(Int)AddTo(Int)
(Int)And(Real)AddTo(Real)
(Char)And(Char)AddTo(String)
(Char)And(String)AddTo(String)
(Int)And(Char)MultiplyTo(String)
(Int)And(String)MultiplyTo(String)
(Char)SubtractsFrom(String)To(String)
\end{verbatim}
This allows us to use the familiar arithmetic operators in types that are not
necessarily numbers but it is somewhat intuitively obvious what the should do
in those other types. Furthermore, their behaviour can be defined by the user
for new user defined types!

\subsubsection{Comparison and Boolean Operators}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
= /= & (A)HasEquality \Ra (A, A) \ra Bool \\
\hline
\texttt{> < >= <=} & (A)HasOrder \Ra (A, A) \ra Bool \\
\hline
\texttt{\& |} & (Bool, Bool) \ra Bool \\
\hline
\end{tabular}
\end{center}
The comparison and boolean operators behave the same as in \H\ and very
similarly to most programming languages. The main difference is that in lcases
the "equals", "and" and "or" operators have the symbol once \\(\texttt{= \& |})
rather than twice (\texttt{== \&\& ||}).

\subsubsection{Environment Action Operators}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{;>} & (E)IsAnEnvAction \Ra (E(A), A \ra E(B)) \ra E(B) \\
\hline
\texttt{;} & (E)IsAnEnvAction \Ra (E(A), E(B)) \ra E(B) \\
\hline
\end{tabular}
\end{center}

\paragraph{line Example}
\begin{verbatim}
print_string("I'll repeat the line.") ; get_line ;> print_string
\end{verbatim}
The example above demonstrates the use of the environment action operators with
the \texttt{IOAction} environment action, which is how IO is done in
lcases. Some light can be shed on how this is done, if we take a look at the
types (as always!):
\begin{verbatim}
print_string  :  String => (EmptyValue)IOAction
print_string("I'll repeat the line.")  : (EmptyValue)IOAction
get_line  :  (String)IOAction

;  :  (E)IsAnEnvAction --> (E(A), E(B)) => E(B) 
print_string("I'll repeat the line.") ; get_line  :  (String)IOAction
  where
  (IOAction)IsAnEnvAction, E = IOAction, A = EmptyValue, B = String

;>  :  (E)IsAnEnvAction --> (E(A), A => E(B)) => E(B) 
print_string("I'll repeat the line.") ; get_line ;> print_string  :  (EmptyValue)IOAction
  where
  (IOAction)IsAnEnvAction, E = IOAction, A = String, B = EmptyValue
\end{verbatim}

\paragraph{Example program}
\begin{verbatim}
main : (EmptyValue)IOAction
  = print_string <- "Hello! What's your name?" ; get_line ;> name =>
    print_string("Oh hi " + name + "! What's your age?") ; get_line ;> age =>
    print_string("Oh that's crazy " + name + "! I didn't expect you to be " + age + "!");
\end{verbatim}
In this bigger but similar example the types are:
\begin{verbatim}
print_string  :  String => (EmptyValue)IOAction
get_line  :  (String)IOAction

print_string <- "Hello! ... "  :  (EmptyValue)IOAction
print_string("Oh hi...)  :  (EmptyValue)IOAction
print_string("Oh that's crazy...)  :  (EmptyValue)IOAction

;  :  (E)IsAnEnvAction --> (E(A), E(B)) => E(B) 
print_string("Oh hi...) ; get_line  :  (String)IOAction
  where
  (IOAction)IsAnEnvAction, E = IOAction, A = EmptyValue, B = String

age => print_string("Oh that's crazy...)  :  String => (EmptyValue)IOAction

;>  :  (E)IsAnEnvAction --> (E(A), A => E(B)) => E(B) 

print_string("Oh hi...) ; get_line ;> age =>
print_string("Oh that's crazy...) :  (EmptyValue)IOAction
  where
  (IOAction)IsAnEnvAction, E = IOAction, A = String, B = EmptyValue

print_string <- "Hello..." ; get_line  :  (String)IOAction
name => print_string("Oh hi ... (till the end)  :  String => (EmptyValue)IOAction

print_string <- "Hello..." ; get_line ;> name =>
print_string("Oh hi ... (till the end)
   :  (EmptyValue)IOAction
\end{verbatim}
Therefore, "\texttt{main\ :\ (EmptyValue)IOAction}" checks out.  The key here is
to remember that function expressions extend to the end of the whole
expression. Therefore, we have "\texttt{name => ... (till the end)}" and
"\texttt{age => ... (till the end)}" as the second arguments of the two
occurences of the "\texttt{;>}" operator. 

\paragraph{Description}\pend
The environment action operators are used to combine values that have some
environment action embedded. Environment actions are also represented by
types. These types take other types as arguments and produce new types (just
like ListOf()s). The values of the type \texttt{E(A)} where
\texttt{(E)IsAnEnvAction} have inside both a value of type \texttt{A}
together with an environment action of type \texttt{E}.
\\\\
The effect of the operator "\texttt{;}" described in words is the following:
given a value of type \texttt{E(A)} (which is a value of type \texttt{A} with
an environment action of type \texttt{E}) and a value of type \texttt{E(B)}
(which is a value of type \texttt{B} with an environment action of type
\texttt{E}), combine those two values by producing the value of type \texttt{B}
with a new environment action of type \texttt{E} which is the combination of
the two environment actions. The overall effect produces a value of type
\texttt{B} with an environment action of type \texttt{E} and therefore the
overall value is of type \texttt{E(B)}.
\\\\
Note that the value of type \texttt{A} inside the first value is not used
anywhere. This is mostly used when \texttt{A = EmptyValue}.  This happens
because values of type \texttt{E(EmptyValue)} are used for their environment
action only \\(e.g. \texttt{print_string(...)\ :\ (EmptyValue)IOAction}).
\\\\
How the two environment actions of the \texttt{E(A)} and \texttt{E(B)} values
are combined to produce the new environment action is specific to the
envoriment action type \texttt{E}.
\\\\
The effect of the operator "\texttt{;>}" described in words is the following:
given a value of type \texttt{E(A)} (which is a value of type \texttt{A} with
an environment action of type \texttt{E}) and a value of type \texttt{A =>
E(B)} (which is a function from a value of type \texttt{A} to a value of type
\texttt{B} with an environment action of type \texttt{E}), combine those two
values by passing the value of type \texttt{A} inside the first value as an
argument to the second value. This results in a value of type \texttt{E(B)}
(which is a value of type \texttt{B} with an environment action of type
\texttt{E}).  Then, produce this value of type \texttt{B} with a new
environment action of type \texttt{E} that is produced by combining the first
environment action with the resulting environment action.  The overall effect
produces a value of type \texttt{B} with an environment action of type
\texttt{E} and therefore the overall value is of type \texttt{E(B)}.

\subsubsection{Operator Expressions}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
1 + 2
1 + x * 3 ^ y
"Hello " + "World!"
x -> f -> g
f o> g o> h
x = y
x >= y - z & x < 2 * y
get_line ; get_line ;> line => print("Second line: " + line)
\end{verbatim}

\item \textit{Description}\\\\
Operator expressions are expressions that use operators. Operators act like
two-argument-functions that are placed in between their arguments. Therefore,
they have function types and they act as it is described in their respective
sections above this one.
\\\\
An operator expression might have multiple operators. The order of operations
is explained in the next section ("Complete Table, Precedence and Associativity")
in Table \ref{table:precassoc}.
\\\\
Just like functions, the sub-expressions
that act as arguments to an operator, must have types that match the types 
expected by the operator.
\\\\
It is possible to end an operator expression with a function. This is mostly
useful with the "\texttt{;>}" operator (see previous section: "Environment
Operators"), but it is also possible with the following operators:
"\texttt{->}", "\texttt{o>}", "\texttt{<o}".

\item \textit{Grammar}
\begin{grammar}
<one-line-op-expr> ::= <args-ops> `\ ' <last-op-arg>

<args-ops> ::= <op-arg> `\ ' <op>  ( `\ ' <op-arg>  `\ ' <op> )*

<op-arg> ::= <basic-expr> | <paren-expr>

<last-op-arg> ::= <op-arg> | <one-line-func-expr>

<op> ::= 
`->' | `<-' | `o>' | `<o' | `^' | `*' | `/' | `+' | `-' |
`=' | `/=' | `>' | `<' | `>=' | `<=' | `\&' | `|' | `;>' | `;'\\

<stretched-op-expr> ::=
<args-ops> ( `\\n' <indentation> <args-ops> )* <stretched-last-op-arg>

<stretched-last-op-arg> ::= 
`\\n' <indentation> <last-op-arg> | `\ ' ( <op-arg> | <stretched-func-expr> )\\

<general-op-expr> ::=
<args-ops> ( `\\n' <indentation> <args-ops> )+ <last-general-op-arg>

<last-general-op-arg> ::= 
`\\n' <indentation> <last-op-arg> |
`\ ' ( <op-arg> | <stretched-func-expr> | <cases-func-expr> )
\end{grammar}
\end{itemize}

\subsubsection{Complete Table, Precedence and Associativity}
\begin{table}[h!]

\caption{
The complete table of lcases operators along with their types and 
their short descriptions.
}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type & Description \\ 
\hline
\hline
\texttt{->} & (A, A \ra B) \ra B & Right function application \\
\hline
\texttt{<-} & (A \ra B, A) \ra B & Left function application \\
\hline
\texttt{o>} & (A \ra B, B \ra C) \ra (A \ra C) & Right function composition \\
\hline
\texttt{<o} & (B \ra C, A \ra B) \ra (A \ra C) & Left function composition \\
\hline
\texttt{\^} & (A)ToThe(B)Gives(C) \Ra (A, B) \ra C & General exponentiation  \\
\hline
\texttt{*} & (A)And(B)MultiplyTo(C) \Ra (A, B) \ra C & General multiplication  \\
\hline
\texttt{/} & (A)Divides(B)To(C) \Ra (B, A) \ra C & General division \\
\hline
+ & (A)And(B)AddTo(C) \Ra (A, B) \ra C & General addition \\ 
\hline
- & (A)SubtractsFrom(B)To(C) \Ra (B, A) \ra C & General subtraction \\
\hline
= /= & (A)HasEquality \Ra (A, A) \ra Bool & Equality operators \\
\hline
\texttt{> < >= <=} & (A)HasOrder \Ra (A, A) \ra Bool & Order operators \\
\hline
\texttt{\& |} & (Bool, Bool) \ra Bool & Boolean operators \\
\hline
\texttt{;>} & (E)IsAnEnvAction \Ra (E(A), A \ra E(B)) \ra E(B) &
Monad bind \\
\hline
\texttt{;} & (E)IsAnEnvAction \Ra (E(A), E(B)) \ra E(B) &
Monad then \\
\hline
\end{tabular}
\end{center}

\label{table:allops}

\end{table}\mbox{}\\
The order of operations is done from highest to lowest precedence. In the same
level of precedence the order is done from left to right if the associativity
is "Left" and from right to left if the associativity is "Right". For the
operators that have associativity "None" it is not allowed to place them in the
same operator expression. The precedence and assosiativity of the operators
is shown in the table below.
\begin{table}[h!]

\caption{ The table of precedence and associativity of the lcases operators.  }

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Precedence & Associativity \\ 
\hline
\hline
\texttt{->} & 10 (highest) & Left \\
\hline
\texttt{<-} & 9 & Right \\
\hline
\texttt{o> <o} & 8 & Left \\
\hline
\texttt{\^} & 7 & Right \\
\hline
\texttt{* /} & 6 & Left \\
\hline
\texttt{+ -} & 5 & Left \\ 
\hline
\texttt{= /= > < >= <=} & 4 & None \\
\hline
\texttt{\&} & 3 & Left \\
\hline
\texttt{|} & 2 & Left \\
\hline
\texttt{;> ;} & 1 & Left \\
\hline
\end{tabular}
\end{center}

\label{table:precassoc}

\end{table}

\newpage
\subsection{Function Expressions}
\label{subsec:funcexprs}

\subsubsection{Simple Function Expressions}

\begin{itemize}
\item \textit{Examples}

\begin{verbatim}
a => 17 * a + 42

(x, y, z) => (x ^ 2 + y ^ 2 + z ^ 2) ^ (1 / 2)
\end{verbatim}

\item \textit{Description}\\\\
Simple function expressions are used to define functions or be part of bigger
expressions as anonymous functions. They are comprised by their parameters and
their body. A parameter is either an identifier or the keyword "fields" (see
next section: "fields" Special Parameter). The parameters are either only one,
in which case there is no parenthesis, or they are many, in which case they are
in parenthesis, seperated by commas. The parameters and the body are seperated
by an arrow (" \texttt{=>} "). The body is a basic expression or an operator
expression.

\item \textit{Grammar}
\begin{grammar}
<one-line-func-expr> ::=
<parameters> `\ =>\ ' ( <basic-expr> | <one-line-op-expr> )

<parameters> ::= <parameter> | `(' <parameter> ( `,\ ' <parameter> )+ `)'

<parameter> ::= <identifier> | `fields'\\

<stretched-func-expr> ::= <parameters> `\ =>' <stretched-func-body>

<stretched-func-body> ::= ""\\
`\ ' ( <basic-expr> | <one-line-op-expr> ) | 
`\\n' <indentation> ( <basic-expr> | <stretched-op-expr> )
\end{grammar}
\end{itemize}

\subsubsection{"fields" Special Parameter}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
add_ints_and_print_with_string: Int x Int x String
  = fields => print("Ints: " + (1st + 2nd) + "\nString: " + 3rd)

tuple_type GcdAndCoeffs
value (gcd, a, b) : Int x Int x Int

print_gcd_equation : (Int, Int, GcdAndCoeffs) => (EmptyValue)IOAction
  = (x, y, fields) => print("gcd = " + gcd + " = " + sum_string)
    where
    sum_string : String
      = a + " * " + x + " + " + b + " * " + y
\end{verbatim}

\item \textit{Description}\\\\
The \textbf{"fields"} special parameter can be used when the parameter is of a
\textbf{product type} (e.g. \texttt{Int x Int x String}) or of a \textbf{tuple
type} (see "Tuple Types" section \ref{subsubsec:tupts}).  It allows the direct
use of the \textbf{subvalues (fields)} of that parameter in the function body
without the need to name the parameter itself. This is very useful when the
whole parameter is not used but (some or all of) it's subvalues are.
\\\\
In the case where the parameter is of a \textbf{product type} the special identifiers
"1st, 2nd, 3rd, 4th and 5th" can be used for the respective subvalues.
Similarly, when the parameter is of a \textbf{tuple type} the identifiers used in
the type's definition can be used for the subvalues. 
\\\\
The use of the \textbf{"fields"} keyword in multiple parameters is possible as
long as it is not used in two or more parameters of the same type, to avoid 
ambiguities.

\end{itemize}

\subsubsection{"cases" Function Expressions}
\label{subsubsec:casessyntax}

\begin{itemize}
\item \textit{Examples}

\begin{verbatim}
print_sentimental_bool : Bool => (EmptyValue)IOAction
  = cases =>
    true => print <- "It's true!! :)"
    false => print <- "It's false... :("

or_type TrafficLight
values green | amber | red

print_sentimental_traffic_light : Bool => (EmptyValue)IOAction
  = cases =>
    green => print <- "It's green! Let's go!!! :)"
    amber => print <- "Go go go, fast!"
    red => print <- "Stop right now! You're going to kill us!!"

is_not_red : TrafficLight => Bool
  = cases =>
    green => true
    amber => true
    red => false

is_seventeen_or_forty_two : Int => Bool
  = cases => 
    17 => true
    42 => true
    ... => false
 
traffic_lights_match : (TrafficLight, TrafficLight) => Bool
  = (cases, cases) =>
    green, green => true
    amber, amber => true
    red, red => true
    ... => false

gcd : (Int, Int) => Int
  = (x, cases) =>
    0 => x
    y => gcd(y, x -> mod <- y) 

is_empty : ListOf(A)s => Bool
  = cases => 
    empty => true
    non_empty:anything => false

apply()to_all: (A => B, ListOf(A)s) => ListOf(B)s
  = (f, cases) =>
    empty => empty
    non_empty:list => non_empty:(f <- list.head, apply(f)to_all <- list.tail)

\end{verbatim}

\item \textit{Description}\\\\
"cases" is a keyword that works as a special parameter. The difference is that 
instead of giving the name "cases" to that parameter, it let's you 
pattern match on the possible values of that parameter and return a different
result for each particular case. 
\\\\
The "cases" keyword can only be used on parameters that have either one of the 
basic types (Int, Real, Char, String) or an or\_type (e.g. Bool, ListOf(A)s).
\\\\
The last case can be "\texttt{... => (body of default case)}" to capture all
remaining cases while dismissing the value (e.g.
\texttt{is_seventeen_or_forty_two} example), or it can be
"\texttt{some_id => (body of default case)}" to capture all remaining
cases while being able to use the value with the name "\texttt{some_id}"
(e.g.  "y" in \texttt{gcd} example).
\\\\
It is possible to use the "cases" keyword in multiple parameters to match on all
of them. By doing that, each case represents a particular combination of values
for the parameters involved (e.g. \texttt{traffic_lights_match} example).
\\\\
A function expression that uses the "cases" syntax must contain the "cases"
keyword in at least one parameter. The number of matching expressions in 
all cases must be the same as the number of parameters with the "cases" keyword.

\item \textit{Grammar}
\begin{grammar}
<cases-func-expr> ::= <cases-parameters> `\ =>' <cases> \\

<cases-parameters> ::=
<cases-parameter> | `(' <cases-parameter> ( `,\ ' <cases-parameter> )+ `)'

<cases-parameter> ::= <parameter> | `cases'\\

<cases> ::= <case>+ [ <default-case> ]

<case> ::= `\\n' <indentation> <matching> ( `,\ ' <matching> )* `\ =>' <case-body>

<default-case> ::= `\\n' <indentation> `...\ =>' <case-body>\\

<matching> ::= <literal> | <identifier> [ `:' <identifier> ]

<case-body> ::=
( `\ ' <one-line-op-expr> | `\\n' <indentation> <stretched-op-expr> )
[ <where-expr> ]
\end{grammar}

\end{itemize}

\subsection{Value Definitions, "where" and Indentation}
\label{subsec:valdefswhere}

\subsubsection{Value Definitions}
\label{subsubsec:valdefs}

\begin{itemize}

\item \textit{Examples}

\begin{verbatim}
foo : Int
  = 42

val1, val2, val3 : Int, Bool, Char
  = 42, true, 'a'

int1, int2, int3 : all Int
  = 1, 2, 3

f : (Int, Int, Int) => Int
  = (a, b, c) => a + b * c
\end{verbatim}

\item \textit{Description}\\\\
Value definitions are the main building block of lcases programs. To define a
new value you give it a name, a type and an expression. It is possible to group
value definitions together by seperating the names, the types and the
expressions with commas. This is very useful for not cluttering the program
with many definitions for values with small expressions (e.g. constants).  When
grouping definitions together it is also possible to use the keyword "all" to
give the same type to all the values.
\\\\
The name and the type are seperated by the string " : ". The line below is
indented two spaces more than the "name-type" line, begins with "= " and
continues with the expression.  The value definitions are either begining in
the first column, in which case the can be "seen" by all other definitions, or
they are in a "where" expression (see section below), in which case they can be
"seen" by the expression specified by the indentation rules (see "Indentation
System" section \ref{subsubsec:indsys}).

\item \textit{Grammar}
\begin{grammar}
<value-def> ::= ""\\
<indentation> <identifier> `\ :\ ' <type> \\
`\\n' <indentation> `=\ ' <value-expr> [ <where-expr> ]

<value-expr> ::= <basic-expr> | <op-expr> | <func-expr> 

<grouped-value-defs> ::= ""\\
<indentation> <identifier> ( `,\ ' <identifier> )+ `\ :\ '
( <type> ( `,\ ' <type> )+ | `all' <type> ) \\
`\\n' <indentation> `=\ '
<basic-or-one-line-expr> ( [ `\\n' <indentation> ] `,\ ' <basic-or-one-line-expr> )+
\end{grammar}

\end{itemize}

\subsubsection{"where" Expressions}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
sort : (A)HasOrder --> ListOf(A)s => ListOf(A)s
  = cases => 
    empty => empty
    non_empty:l => sort(less_l) + l.head + sort(greater_l)
      where
      less_l : ListOf(A)s
        = filter_with(x => x < l.head, l.tail)
      greater_l : ListOf(A)s
        = filter_with(x => x >= l.head, l.tail)

tuple_type Coeffs
value (previous, current) : Int x Int

tuple_type GcdAndCoeffs
value (gcd, a, b) : Int x Int x Int

ext_euc: (Int, Int) => GcdAndCoeffs
  = ext_euc_rec((1, 0), (0, 1))

ext_euc_rec: (Coeffs, Coeffs, Int, Int) => GcdAndCoeffs
  = (a_coeffs, b_coeffs, x, cases) =>
    0 => (x, a_coeffs.previous, b_coeffs.previous)
    y => ext_euc_rec(next <- a_coeffs, next <- b_coeffs, y, x -> mod <- y)
      where
      next: Coeffs => Coeffs
        = fields => (current, previous - x / y * current)

big_string : String
  = s1 + s2 + s3 + s4
    where
    s1, s2, s3, s4 : all String
      = "Hello, my name is Struggling Programmer."
      , "I have tried way too many times to fit a big chunk of text"
      , "inside my program, without it hitting the half-screen mark!"
      , "I am so glad I finally discovered lcases!!!"
\end{verbatim}

\item \textit{Description}\\\\
"where" expressions allow the programmer to use values inside an expression and
define them below it. They are very useful for reusing or abbreviating
expressions that are specific to a particular definition (i.e. they are not
used anywhere outside that definition). "where" expressions begin by a line
that only has word "where" in it and is indented so that it follows the
indentation rules (see "Indentation System" section below).
The definitions are placed below the "where" line and must have the same
indentation. 

\item \textit{Grammar}
\begin{grammar}
<where-expr> ::=
`\\n' <indentation> `where\\n' ( <value-def> | <grouped-value-defs> )+
\end{grammar}

\end{itemize}

\subsubsection{Indentation System}
\label{subsubsec:indsys}

The \textit{$<$indentation$>$} nonterminal in not a normal BNF nonterminal. It is a
context sensitive construct that enforces the indentation rules of lcases.

\paragraph{Informal indentation rules}
\begin{itemize}

\item
An expression inside parentheses (which extends over multiple lines)
is indented more than the lines with

\end{itemize}

Whenever
the \textit{$<$indentation$>$} nonterminal appears in the grammar there must be
2*indetation level


\subsection{Types}
\label{subsec:types}

\subsubsection{Type expressions}

\paragraph{Examples}

\begin{verbatim}
Int

String => String 

Int x Int 

Int x Int => Real

A => A

(A => B, B => C) => (A => C)

((A, A) => A, A, ListOf(A)s) => A

((B, A) => B, B, ListOf(A)s) => B

(T)HasStringRepresantion --> T => String
\end{verbatim}

\paragraph{Description}\pend
\begin{tabular}{ |c|c| } 
\hline
Examples & Description \\ 
\hline
\hline
Int & \\
Char & Base types \\
String & \\ 
\hline
A \ra A &
Polymorphic types. A, B, C ... are type variables
\\
(A \ra B, B \ra C) \ra (A \ra C) &
\\ 
\hline
\end{tabular}

\paragraph{Differences from Haskell}\pend
\begin{tabular}{ |c|c|c| } 
\hline
lcases & haskell & difference description \\ 
\hline
\hline
A \ra A & a \ra a & Type variables for polymorphic types are  \\ 
\hline
\end{tabular}

\paragraph{Grammar}
\begin{grammar}
<type> ::= <type-application> | <product-type> | <function-type> \\

<type-application> ::=
[ <types-in-paren> ] <type-identifier> (<types-in-paren> ( [A-Za-z] )*)* [ <types-in-paren> ] 

<types-in-paren> ::= `(' <type> (`, ' <type>)* `)'

<type-identifier> ::= [A-Z] ( [A-Za-z] )* \\ 
 
<product-type> ::= <product-subtype> ( `\ x\ ' <product-subtype> )+

<product-subtype> ::=
`(' ( <function-type> | <product-type> ) `)' | <type-application> \\

<function-type> ::= <input-types-expression> `\ =>\ ' <one-type>

<input-types-expression> ::= <one-type> | <two-or-more-types-in-paren>

<one-type> ::= <type-application> | <product-type> | `(' <function-type> `)'

<two-or-more-types-in-paren> ::=  `(' <type> (`, ' <type>)+ `)'
\end{grammar}

\subsubsection{Tuple Types}
\label{subsubsec:tupts}

\paragraph{Definition Examples}

\begin{verbatim}
tuple_type Name
value (first_name, last_name) : String x String

tuple_type ClientInfo
value (name, age, nationality) : Name x Int x String

tuple_type Date
value (day, month, year) : Int x Int x Int

tuple_type (A)And(B)
value (a_value, b_value) : A x B

tuple_type (ExprT)WithPosition
value (expr, line, column) : ExprT x Int x Int
\end{verbatim}

\paragraph{Usage Examples}

\begin{verbatim}
giorgos_info : ClientInfo
  = (("Giorgos", "Papadopoulos"), 42, "Greek")

john_info : ClientInfo
  = (("John", "Doe"), 42, "American")

name_to_string : Name => String
  = fields => "First Name: " + first_name + "\nLast Name: " + last_name

print_name_and_nationality : ClientInfo => (EmptyValue)IOAction
  = fields => print(name -> name_to_string + "\nNationality: " + nationality)

print_error_in_expr : (SomeDefinedExprT)WithPosition => (EmptyValue)IOAction
  = ewp =>
    print("Error in the expression:" + es + "\nAt the position: (" + ls + ", " + cs + ")")
    where
    es, ls, cs : all String
      = ewp.expr->to_string, ewp.line->to_string, ewp.column->to_string
\end{verbatim}

\paragraph{Description}\pend
Tuple types group many values into a single value. They are specified by their name,
the names of their subvalues and the types of their subvalues. They generate 
projection functions for all of their subvalues by using a '.' before the name of 
the subvalue. For example the ClientInfo type above generates the following 
functions:
\begin{verbatim}
.name : ClientInfo => String
.age : ClientInfo => Int
.nationality : ClientInfo => String
\end{verbatim}
These functions shall be named "postfix functions" as the can just be appended to
their argument.

\paragraph{Definition Grammar}
\begin{grammar}
<tuple-type-definition> ::= ""\\
`tuple_type\ ' <type-application>
\\`\\nvalue\ ' `(' <identifier> (`,\ ' <identifier>)* `)' `\ :\ ' <product-type>
\end{grammar}

\subsubsection{Or Types}

\paragraph{Examples}

\begin{verbatim}
or_type Bool
values true | false

or_type Possibly(A)
values the_value:A | no_value

or_type ListOf(A)s
values non_empty:NonEmptyListOf(A)s | empty

tuple_type NonEmptyListOf(A)s
value (head, tail) : A x ListOf(A)s

is_empty : ListOf(A)s => Bool
  = cases => 
    empty => true
    non_empty:anything => false

get_head : ListOf(A)s => Possibly(A)
  = cases => 
    empty => no_value
    non_empty:list => the_value:list.head
\end{verbatim}

\paragraph{Description}\pend
Values of an or\_type are one of many cases that possibly have other values
inside.  The cases which have other values inside are followed by a semicolon
and the type of the internal value. The same syntax can be used for matching
that particular case in a function using the "cases" syntax, with the
difference that after the colon, we write the name given to the value inside.
Or\_types and basic types are the only types on which the "cases" syntax can be
used. The cases of an or\_type which have a value inside create functions. For
example, the case "non\_empty" of a list creates the function "non\_empty:" for
which we can say:
\begin{verbatim}
non_empty: : NonEmptyListOf(A)s => ListOf(A)s
\end{verbatim}
Similarly:
\begin{verbatim}
the_value: : A => Possibly(A)
\end{verbatim}
These functions shall be named "prefix functions" as they are prepended to their
argument.
For example:
\begin{verbatim}
head_and_tail : NonEmptyListOf(Int)s
  = (1, [2, 3, 4])

list : ListOf(Int)s
  = non_empty:head_and_tail
\end{verbatim}
These functions can be used like any other function as arguments to other functions.
For example:
\begin{verbatim}
heads_and_tails_to_lists : ListOf(NonEmptyListOf(A)s)s => ListOf(ListOf(A)s)s
  = apply(non_empty:)to_each
\end{verbatim}

\paragraph{Definition Grammar}
\begin{grammar}
<or-type-definition> ::= ""\\
`or_type\ ' <type-application> 
\\`\\nvalues\ ' <identifier> [ `:' <type> ] ( `\ |\ ' <identifier> [ `:' <type> ])*
\end{grammar}

\subsection{Type Logic}
\label{subsec:typelogic}

\subsubsection{Type Predicate}

\subsubsection{Type Proposition}

\subsubsection{Type Theorem}

\subsection{Predefined}

\subsubsection{Functions}

\subsection{Program}

\subsubsection{"main" Value}

\subsection{Complete Grammar}

\setlength{\grammarparsep}{20pt}
\setlength{\grammarindent}{12em}

\paragraph{Program}
\begin{grammar}

<program> ::= (<value-definitions> | <type-def>)+

\end{grammar}

\section{lcases vs Haskell: Similarities and Differences}

\section{Parser implimentation}

The parser was implemented using the parsec library.

\subsection{AST Types}

\subsection{Parsers}

\section{Translation to \H}
\section{Running examples}
\section{Conclusion}

\section{To be removed or incorporated}

Functor f $=>$ (A)HasInternalFuncApp\\
Applicative f $=>$ (A)CanApplyWrappedFuncToWrappedArg
\paragraph{Examples in \H}

\begin{verbatim}
data ClientInfo =
  ClientInfoC String Int String

data WithPosition a = 
  WithPositionC a Int Int

data Pair a b = 
  PairC a b
\end{verbatim}

\paragraph{Examples in \H}

\begin{verbatim}
{-# language LambdaCase #-}

data Bool =
  Ctrue | Cfalse

data Possibly a =
  Cwrapper a | Cnothing

data ListOf_s a =
  Cnon_empty (NonEmptyValueListOf_s a) | Cempty

data NonEmptyValueListOf_s a =
  CNonEmptyValueListOf_s a (ListOf_s a)

is_empty :: ListOf_s a => Bool
is_empty = \case
  Cempty => Ctrue
  Cnon_empty (CNonEmptyValueListOf_s head tail) => Cfalse

get_head :: ListOf_s a => Possibly a
get_head = \case
  Cempty => Cnothing
  Cnon_empty (CNonEmptyValueListOf_s head tail) => Cwrapper head
\end{verbatim}

\paragraph{Examples in \H}
\begin{verbatim}
foo :: Int
foo = 42

val1 :: Int
val1 = 42
val2 :: Bool
val2 = true
val3 :: Char
val3 = 'a'

int1 :: Int
int1 = 1
int2 :: Int
int2 = 2
int3 :: Int
int3 = 3

succ :: Int => Int
succ = \x => x + 1

f :: Int => Int => Int => Int
f = \a b c => a + b * c
\end{verbatim}

Or Types the following have automatically generated functions:

\begin{verbatim}
is_case:
\end{verbatim}
%\newpage

%\paragraph{Examples}
%
%\begin{verbatim}
%\end{verbatim}

%\paragraph{Description}\pend
%desc

%\paragraph{Examples in \H}
%
%\begin{verbatim}
%\end{verbatim}

% \begin{tabular}{ |c|c| } 
% \hline
% 1 & 2 \\ 
% \hline
% \hline
% 1.1 & 1.2 \\ 
% \hline
% \end{tabular}

%  \includegraphics[width=10cm, height=8cm]{../Images/image.png}
\begin{syntdiag}
<ident> ‘(’
\begin{rep} \begin{stack} \\
<type> \begin{stack} \\ <ident> \end{stack}
\end{stack} \\ ‘,’ \end{rep}
\begin{stack} \\ ‘...’ \end{stack} ‘)’
\end{syntdiag}

\paragraph{Hi}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
\end{verbatim}

\item \textit{Description} \\\\
hi

\item \textit{Grammar}
\begin{grammar}
<identifier> ::= [a-z]( [a-z_] | `()'[a-z_] )* [ [0-9] ]
\end{grammar}

\end{itemize}

\end{document}
