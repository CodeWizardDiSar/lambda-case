\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{syntax}
\usepackage{array}
\usepackage{multirow}
\usepackage[left=2cm,right=2cm,top=2cm]{geometry}

\date{}
\author{
  Dimitris Saridakis
}

\def\imgs{../Images}
\def\H{Haskell}
\def\ra{\texttt{=>}\ }
\def\Ra{\texttt{==>}\ }
\def\pend{\mbox{} \\\\}
%\newcommand\_[_]{_}

\renewcommand{\arraystretch}{1.5}

\begin{document}

\title{
\textbf{Lambda Cases (lcases)}
}
\maketitle

%\setcounter{tocdepth}{4}
%\setcounter{secnumdepth}{4}
\tableofcontents

\section{Introduction}

\H\ is a delightful language. Yet, for some reason, it doesn't seem to have
it's rightful place in terms of popularity in industry. Why is it so?  Is it
inherently hard to learn and therefore only the brave dare to use it, or could
it be that the syntax is perplexing to the amateur eye? It is my belief that
with some syntax changes that give a greater familiarity to the new user, there
would be no language more compelling than (the new) \H. In an attempt to
achieve that familiarity, I present some (hopefully useful) new syntax, of
which some is closer to the imperative/OOP style (to attract more already
experienced programmers from these languages), some is closer to mathematics
(in which most programmers should be experienced) and some is closer to natural
language (in which we are all already experienced). 

\section{Language Description: General}

\subsection{Program Structure}

An lcases program consists of a set of definitions and theorems.  Definitions
are split into value definitions, type definitions and type proposition
definitions. Theorems are proven type propositions.  The definition of the
"main" value determines the program's behaviour. Functions as well as
"Environment Actions" (see section \ref{subsec:envacts}) are also considered
values.

\paragraph{Program example: extended euclidean alogirthm}
\begin{verbatim}
// type definitions

tuple_type Coeffs
value (previous, current) : Int x Int

tuple_type GcdAndCoeffs
value (gcd, a, b) : Int x Int x Int

// algorithm

ext_euc
  : (Int, Int) => GcdAndCoeffs
  = ext_euc_rec(init_a_coeffs, init_b_coeffs)
    where
    init_a_coeffs, init_b_coeffs
      : all Coeffs
      = (1, 0), (0, 1)
    ext_euc_rec
      : (Coeffs, Coeffs, Int, Int) => GcdAndCoeffs
      = (a_coeffs, b_coeffs, x, cases) =>
        0 => (x, a_coeffs.previous, b_coeffs.previous)
        y => ext_euc_rec(next <- a_coeffs, next <- b_coeffs, y, x -> mod <- y)
          where
          next
            : Coeffs => Coeffs
            = cs => (cs.current, cs.previous - x -> div <- y * cs.current)

// reading, printing and main

read_two_ints
  : (Int x Int)IOAction
  = print <- "Please give me 2 ints";
    get_line ;> split_words o> apply(from_string)to_all o> cases =>
      [x, y] => (x, y) -> io_action
      ... => io_error <- "You didn't give me 2 ints"
 
print_gcd_equation
  : (Int, Int, GcdAndCoeffs) => (EmptyVal)IOAction
  = (x, y, gcd_cs) => print("gcd = " + gcd_cs.gcd + " = " + linear_comb_string)
    where
    linear_comb_string
      : String
      = gcd_cs.a + " * " + x + " + " + gcd_cs.b + " * " + y

main
  : (EmptyVal)IOAction
  = read_two_ints ;> ints =>
    print_gcd_equation(ints.1st, ints.2nd, ext_euc(ints.1st, ints.2nd))
\end{verbatim}

\paragraph{Program grammar}
\begin{grammar}
<program> ::= ( <value-def> | <type-def> | <type-prop-def> )+
\end{grammar}

\subsection{Keywords}

The lcases keywords are the following:
\begin{verbatim}
cases where all tuple_type value or_type values
type_predicate function type_proposition equivalent type_theorem proof
\end{verbatim}
Each keyword's functionality is described in the respective section shown in the 
table below:

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Keyword & Section \\ 
\hline
\hline
\texttt{cases} & \ref{subsec:funcexprs} Function Expressions \\
\hline
\texttt{where all} & \ref{subsec:valdefswhere} Value Definitions \\
\hline
\texttt{tuple_type value or_type values} & \ref{subsec:types} Types \\
\hline
\texttt{type_predicate function type_proposition equivalent} &
  \multirow{2}{*}{\ref{subsec:typelogic} Type Logic} \\
\texttt{type_theorem proof} & \\
\hline
\end{tabular}
\end{center}
The "\texttt{cases}" and "\texttt{where}" keywords are also
reserved words. Therefore, even though they can be generated by the
"identifiers" grammar, they cannot be used as identifiers (see "Literals and
Identifiers" section \ref{subsubsec:litsandidents}).

\section{Language Description: Values}

\subsection{Basic Expressions}

\subsubsection{Literals and Identifiers}
\label{subsubsec:litsandidents}

\paragraph{Literals}
\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
1  2  17  42  -100
1.61  2.71  3.14  -1234.567
'a'  'b'  'c'  'x'  'y'  'z'  '.'  ','  '\n'
"Hello World!"  "What's up, doc?"  "Alrighty then!"
\end{verbatim}

\item \textit{Description} \\\\
There are literals for the four basic types: Int, Real, Char, String. These are the 
usual integers, real numbes, characters and strings. The exact specification of 
literals is the same as in the \H\ report.

\item \textit{Grammar}
\begin{grammar}
<literal> ::= <literal>
\end{grammar}
TODO add the grammar from the haskell report

\end{itemize}


\paragraph{Identifiers}
\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
x y z
a1 a2 a3 
funny_identifier 
unnecessarily_long_identifier
apply()to_all
\end{verbatim}

\item \textit{Description} \\\\
An identifier is the name of a value or a parameter. It is used in the
definition of a value (see "value definition" section
\ref{subsec:valdefswhere}) and in expressions that use that value, or in the
parameters of a function and in the body of that function.
\\\\
An identifier starts with a lower case letter and is followed by lower case
letters or underscores. It is also possible to have pairs of parentheses in the
middle of an identifier (see "Parenthesis Function Application" section
\ref{subsec:parenfuncapp} for why this can be useful).  Finally, an identifier
can be ended with a digit.

\item \textit{Grammar}
\begin{grammar}
<identifier> ::= [a-z] [a-z_]* ( `()' [a-z_]+ )* [ [0-9] ]
\end{grammar}
Even though the "\texttt{cases}" and "\texttt{where}" keywords can be generated
by this grammar, they cannot be used as identifiers.

\end{itemize}

\newpage
\subsubsection{Parenthesis, Tuples and Lists}

\paragraph{Parenthesis}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
(1 + 2)
(((1 + 2) * 3) ^ 4)
(x => f(x) + 1)
(s => "f(val) + 1 is: " + s)
(val -> (x => f(x) + 1) -> to_string -> (s => "f(val) + 1 is: " + s))
("Line is: " + line)
(get_line ;> line => print("Line is: " + line))
(do(3)times <- (get_line ;> line => print("Line is: " + line)))
\end{verbatim}

\item \textit{Description} \\\\
An expression is put in parenthesis to prioritize it or isolate it in a bigger
(operator) expression. The expressions inside parethesis are operator
or function expressions.

\item \textit{Grammar}
\begin{grammar}
<paren-expr> ::= `(' <op-or-func-expr> `)'  

<op-or-func-expr> ::=
<simple-op-expr> | <op-expr-func-end> | <simple-func-expr>
\end{grammar}

\end{itemize}

\paragraph{Tuples}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
(1, "What's up, doc?")
(2, "Alrighty then!", 3.14)
(x, y, z, w)
(1, my_function, (x, y, z) => (x ^ 2 + y ^ 2 + z ^ 2) ^ (1/2))
\end{verbatim}

\item \textit{Description} \\\\
Tuples are used to group many values (of possibly different types) into one.
The type of the tuple can be either the product of the types of the fields or a
defined tuple\_type which is equivalent to the afformentioned product type (see
"tuple\_type" section \ref{subsubsec:tupts}). For example, the type of the
second tuple above could be:
\begin{verbatim}
Int x String x Real
\end{verbatim}
or:
\begin{verbatim}
MyType
\end{verbatim}
assuming "MyType" has been defined in a similar way to the following:
\begin{verbatim}
tuple_type MyType
value (my_int, my_string, my_real) : Int x String x Real
\end{verbatim}

\item \textit{Big Tuples} \\\\
\textbf{Example}
\begin{verbatim}
my_big_tuple
  : String x Int x Real x String x String x (String x Real x Real)
  = ( "Hey, I'm the first field and I'm also a relatively big string."
    , 42, 3.14, "Hey, I'm the first small string", "Hey, I'm the second small string"
    , ("Hey, I'm a string inside the nested tuple", 2.71, 1.61)
    )
\end{verbatim}

\textbf{Description} \\\\
It is possible to stretch a (big) tuple expression over multiple lines (only)
in a seperate value definition (see "Value Definitions" section
\ref{subsubsec:valdefs}).  In that case:
\begin{itemize}
\item
The character '(' is after the "= " part of the value definition
and the first field must be in the same line.

\item
The tuple can split in a new line only at a ',' character. Every such line must
be indented so that the ',' is in same column where the '(' character was in
the first line.

\item
The tuple must be ended by a line that only contains the ')' character and is 
also indented so that the ')' is in same column where the '(' character was in
the first line.

\item
The precise indentation rules are described in the section
"Indentation System" \ref{subsubsec:indsys}.
\end{itemize}

\item \textit{Grammar}
\begin{grammar}
<tuple> ::= `(' <line-expr> `,\ ' <comma-sep-line-exprs> `)'

<comma-sep-line-exprs> ::= <line-expr> ( `,\ ' <line-expr> )*

<line-expr> ::= <no-paren-op-arg> | <op-or-func-expr> \\

<big-tuple> ::= ""\\
`(' <line-expr> [ `\\n' <indent> ] `,\ ' <comma-sep-line-exprs> \\
( `\\n' <indent> `,' <comma-sep-line-exprs> )* \\
`\\n' <indent> `)' \\

\end{grammar}

\end{itemize}

\paragraph{Lists}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
[1, 2, 17, 42, -100]
[1.61, 2.71, 3.14, -1234.567]
["Hello World!", "What's up, doc?", "Alrighty then!"]
[x => x + 1, x => x + 2, x => x + 3]
[x, y, z, w]
\end{verbatim}

\item \textit{Description} \\\\
Lists are used to group many values of the same type into one. 
The type of the list is ListOf(A)s where A is the type of every value inside.
Therefore, the types of the first four examples are:
\begin{verbatim}
ListOf(Int)s
ListOf(Real)s
ListOf(String)s
(A)And(Int)AddTo(B) ==> ListOf(A => B)s
\end{verbatim}
And the last list is only legal if x, y, z and w all have the same type. Assuming 
they do and it's the type T, the type of the list is: 
\begin{verbatim}
ListOf(T)s
\end{verbatim}

\item \textit{Big Lists} \\\\
It is possible to stretch a (big) list expression over multiple lines (only) in
a seperate value definition (see "Value Definitions" section
\ref{subsubsec:valdefs}).  In that case:
\begin{itemize}
\item
The character '[' is after the "= " part of the value definition
and the first element must be in the same line.

\item
The list can split in a new line only at a ',' character. Every such line must
be indented so that the ',' is in same column where the '[' character was in
the first line.

\item
The tuple must be ended by a line that only contains the ']' character and is 
also indented so that the ']' is in same column where the '[' character was in
the first line.

\item
The precise indentation rules are described in the section
"Indentation System" \ref{subsubsec:indsys}.
\end{itemize}
Example:
\begin{verbatim}
my_big_list
  : ListOf(Int => (EmptyVal)IOAction)s
  = [ x => print("I'm the first function and x + 1 is: " + (x + 1))
    , x => print("I'm the second function and x + 2 is: " + (x + 2))
    , x => print("I'm the third function and x + 3 is: " + (x + 3))
    ]
\end{verbatim}

\item \textit{Grammar}
\begin{grammar}
<list> ::= `[' [ <comma-sep-line-exprs> ] `]'

<big-list> ::= 
`[' <comma-sep-line-exprs>
( `\\n' <indent> `,' <comma-sep-line-exprs> )*
`\\n' <indent> `]'
\end{grammar}

\end{itemize}

\subsubsection{Parenthesis Function Application}
\label{subsec:parenfuncapp}

\begin{itemize}
\item \textit{Examples}

\begin{verbatim}
f(x)
f(x, y, z)
(x)to_string
apply(f)to_all
apply(f)to_all(l)
\end{verbatim}

\item \textit{Description}
\\\\
Function application in lcases can be done in many different ways in an attempt to 
maximize readability. In this section, we discuss the ways function application can
be done with parenthesis.
\\\\
In the first two examples, we have the usual mathematical
function application which is also used in most programming languages and
should be familiar to the reader. That is, function application is done with the 
arguments of the function in parenthesis seperated by commas and \textbf{appended}
to the function identifier.
\\\\
We extend this idea by allowing the arguments to be \textbf{prepended} to the
function identifier (third example). Finally, it is also possible to to have
the arguments \textbf{inside} the function identifier provided the function has
been \textbf{defined with parentheses inside the identifier}. For example,
below is the definition of "apply()to\_all":

\begin{verbatim}
apply()to_all
  : (A => B, ListOf(A)s) => ListOf(B)s
  = (f, cases) =>
    empty => empty
    non_empty:l => non_empty:(f <- l.head, apply(f)to_all <- l.tail)
\end{verbatim}
The actual definition doesn't matter at this point, what matters is that the 
identifier is "apply()to\_all" with the parentheses \textbf{included}. This is very
useful for defining functions where the argument in the middle makes the function
application look and sound more like natural language.
\\\\
It is possible to have many parentheses pairs in a single function application
(last example). The arguments are always inserted to the function from
\textbf{left to right}.  Therefore, when multiple parentheses pairs are present
the arguments of the leftmost parentheses are inserted first then the next ones
to the right and so on.

\item \textit{Grammar}
\begin{grammar}
<paren-func-app> ::= ""\\""
[ <arguments> ] <identifier-with-arguments> [ <arguments> ]
\alt " "<arguments> <identifier> [ <arguments> ]
\alt " "<identifier> <arguments>

<arguments> ::= `(' <comma-sep-line-exprs> `)'

<identifier-with-arguments> ::= ""\\""
[a-z] [a-z_]* ( `()'[a-z_]+ )* <arguments>
[a-z_]+ ( ( `()' | <arguments> ) [a-z_]+ )* 
[ [0-9] ]
\end{grammar}

\end{itemize}

\subsubsection{Prefix and Postfix Functions}
 
\paragraph{Prefix Functions}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
the_value:1
non_empty:l
error:e
result:r
apply(the_value:)to_all
\end{verbatim}

\item \textit{Description} \\\\
Prefix functions are automatically generated from \texttt{or_type} definitions
(see "Or Types" section \ref{subsubsec:orts}). They are functions that
convert a value of a particular type to a value that is a case of an
\texttt{or_type} and has values of this type inside. For example in the
first example above we have:
\begin{verbatim}
1 
  : Int
the_value:1
  : Possibly(Int)
\end{verbatim}
Where the function \texttt{thevalue:} is automatically generated from the
definition of the \texttt{Possibly} type:
\begin{verbatim}
or_type Possibly(A)
values the_value:A | no_value
\end{verbatim}
And it has the type \texttt{A => Possibly(A)}.
\\\\
These functions are called prefix functions because they are prepended to
their argument. However, they can also be used as any other function.
An illustration of the aforementioned is the last example, where the function
\texttt{the_value:} is an argument of the function \texttt{apply()to_all}.
Prefix functions always end with a colon.

\item \textit{Grammar}
\begin{grammar}
<pre-func> ::= <identifier> `:'

<pre-func-app> ::= <pre-func> ( <basic-expr> | <paren-expr> | <pre-func-app> )

<basic-expr> ::=
<literal> | <identifier> | <tuple> | <list> | <paren-func-app> | <post-func-app> 
\end{grammar}

\end{itemize}

\paragraph{Postfix Functions}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
name.first_name
list.head
date.year
tuple.1st
apply(.1st)to_all
\end{verbatim}

\item \textit{Description} \\\\
Postfix functions are automatically generated from \texttt{tuple_type}
definitions (see "Tuple Types" section \ref{subsubsec:tupts}). They are
functions that take a \texttt{tuple_type} value and return a particular field
(i.e. projection functions). For example in the first example above we have:
\begin{verbatim}
name 
  : Name
name.first_name
  : String
\end{verbatim}
Where the function \texttt{.first_name} is automatically generated from the
definition of the \texttt{Name} type:
\begin{verbatim}
tuple_type Name
value (first_name, last_name) : String x String
\end{verbatim}
And it has the type \texttt{Name => String}.
\\\\
There are also the following special projection functions for \textbf{product
types}: \texttt{.1st .2nd .3rd .4th .5th}. For the 4th example above, assuming:
\begin{verbatim}
tuple 
  : Int x String
\end{verbatim}
We have:
\begin{verbatim}
tuple.1st
  : Int
\end{verbatim}
The general types of these functions are:
\begin{verbatim}
.1st
  : (A)Is(B)sFirst ==> B => A
.2nd
  : (A)Is(B)sSecond ==> B => A
...
\end{verbatim}
These functions are called postfix functions because they are appended to
their argument. However, they can also be used as any other function.
An illustration of the aforementioned is the last example, where the function
\texttt{.1st} is an argument of the function \texttt{apply()to_all}.
Postfix functions always begin with a dot.


\item \textit{Grammar}
\begin{grammar}
<post-func> ::= `.' <identifier>

<post-func-app> ::= ( <paren-expr> | <basic-expr> ) <post-func>
\end{grammar}

\end{itemize}

\subsection{Operators}

\subsubsection{Function Application Operators}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{->} & (A, A \ra B) \ra B \\
\hline
\texttt{<-} & (A \ra B, A) \ra B \\
\hline
\end{tabular}
\end{center}
The function application operators "\texttt{->}" and "\texttt{<-}" are a
different way to apply functions to arguments than the usual parenthesis
function application.  They are meant to look like arrows that point from the
argument to the function.  These operators are very useful for chaining many
function applications without the clutter of having to open and close
parentheses for each one of the functions.  For example, assuming we have the
following functions with the behaviour suggested by their names and types:
\begin{verbatim}
apply()to_all
  : (A => B, ListOf(A)s) => ListOf(B)s
string_length
  : String => Int
filter_with
  : (A => Bool, ListOf(A)s) => ListOf(A)s
is_odd
  : Int => Bool
sum_ints
  : ListOf(Int)s => Int
\end{verbatim}
And a list of strings:
\begin{verbatim}
strings
  : ListOf(String)s
\end{verbatim}
Here is a simple way to get the total number of characters in all the strings
that have odd length:
\begin{verbatim}
chars_in_odd_length_strings
  : Int
  = strings -> apply(string_length)to_all -> filter_with(is_odd) -> sum_ints
\end{verbatim}
Ofcourse this can be done equivalently using the other operator:
\begin{verbatim}
chars_in_odd_length_strings
  : Int
  = sum_ints <- filter_with(is_odd) <- apply(string_length)to_all <- strings

\end{verbatim}
These operators can also be used together to put a function between two arguments
if that function is commonly used that way in math (or if it looks better for a
certain function). For example the "mod" function can be used like so:
\begin{center}
\texttt{x -> mod <- y}
\end{center}
Which is equivalent to:
\begin{center}
\texttt{mod(x, y)}
\end{center}

\subsubsection{Function Composition Operators}
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{o>} & (A \ra B, B \ra C) \ra (A \ra C) \\
\hline
\texttt{<o} & (B \ra C, A \ra B) \ra (A \ra C) \\
\hline
\end{tabular}
\end{center}
The function composition operators "\texttt{o>}" and "\texttt{<o}" are used to 
compose functions, each one in the corresponding direction. The use of the letter 'o'
is meant to be similar to the mathematical function composition symbol '\(\circ\)'
and the symbols '\texttt{>}', '\texttt{<}' are used so that the operator points from
the function which is applied first to the function which is applied second.
A neat example using function composition is the following. Assuming we have the
following functions with the behaviour suggested by their names and types: 
\begin{verbatim}
split_words
  : String => ListOf(String)s
apply()to_all
  : (A => B, ListOf(A)s) => ListOf(B)s
reverse_string
  : String => String
merge_words
  : ListOf(String)s => String
\end{verbatim}
We can reverse the all the words in a string like so:
\begin{verbatim}
reverse_words
  : String => String
  = split_words o> apply(reverse_string)to_all o> merge_words
\end{verbatim}
Ofcourse this can be done equivalently using the other operator:
\begin{verbatim}
reverse_words
  : String => String
  = merge_words <o apply(reverse_string)to_all <o split_words
\end{verbatim}


\subsubsection{Arithmetic Operators}
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{\^} & (A)ToThe(B)HasType(C) \Ra (A, B) \ra C \\
\hline
\texttt{*} & (A)And(B)MultiplyTo(C) \Ra (A, B) \ra C \\
\hline
\texttt{/} & (A)Divides(B)To(C) \Ra (B, A) \ra C \\
\hline
\texttt{+} & (A)And(B)AddTo(C) \Ra (A, B) \ra C \\ 
\hline
\texttt{-} & (A)SubtractsFrom(B)To(C) \Ra (B, A) \ra C \\
\hline
\end{tabular}
\end{center}
The usual arithmetic operators work as they are expected, similarly to
mathematics and other programming languages for the usual types. However, they
are generalized. The examples below show their generality:
\begin{verbatim}
>> 1 + 1
2
>> 1 + 3.14
4.14
>> 'a' + 'b'
"ab"
>> 'w' + "ord"
"word"
>> "Hello " + "World!"
"Hello World!"
>> 5 * 'a'
"aaaaa"
>> 5 * "hi"
"hihihihihi"
>> "1,2,3" - ','
"123"
\end{verbatim}
Let's analyze further the example of addition. The type can be read as such:
the '+' operator has the type \\ (A, B) \ra C, provided that the type
proposition (A)And(B)AddTo(C) holds. This proposition being true, means that
addition has been defined for these three types (see section "Type Logic"
\ref{subsec:typelogic} for more on type propositions). For example, by the examples
above we can deduce that the following propositions are true (in the order of the 
examples):
\begin{verbatim}
(Int)And(Int)AddTo(Int)
(Int)And(Real)AddTo(Real)
(Char)And(Char)AddTo(String)
(Char)And(String)AddTo(String)
(Int)And(Char)MultiplyTo(String)
(Int)And(String)MultiplyTo(String)
(Char)SubtractsFrom(String)To(String)
\end{verbatim}
This allows us to use the familiar arithmetic operators in types that are not
necessarily numbers but it is somewhat intuitively obvious what the should do
in those other types. Furthermore, their behaviour can be defined by the user
for new user defined types!

\subsubsection{Comparison and Boolean Operators}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{= /=} & (A)HasEquality \Ra (A, A) \ra Bool \\
\hline
\texttt{>= <=} & (A)HasOrder \Ra (A, A) \ra Bool \\
\hline
\texttt{> <} & (A)And(B)AreComparable \Ra (A, B) \ra Bool \\
\hline
\texttt{\& |} & (Bool, Bool) \ra Bool \\
\hline
\end{tabular}
\end{center}
The comparison and boolean operators behave the same as in \H\ and very
similarly to most programming languages. The main difference is that in lcases
the "equals", "and" and "or" operators have the symbol once \\(\texttt{= \& |})
rather than twice (\texttt{== \&\& ||}).

\subsubsection{Environment Action Operators}
\label{subsec:envacts}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{;>} & (E)IsAnEnvAction \Ra (E(A), A \ra E(B)) \ra E(B) \\
\hline
\texttt{;} & (E)IsAnEnvAction \Ra (E(A), E(B)) \ra E(B) \\
\hline
\end{tabular}
\end{center}

\paragraph{Simple Example}
\begin{verbatim}
print_string("I'll repeat the line.") ; get_line ;> print_string
\end{verbatim}
The example above demonstrates the use of the environment action operators with
the \texttt{IOAction} type, which is how IO is done in lcases. Some light can
be shed on how this is done, if we take a look at the types (as always!):
\begin{verbatim}
print_string
  : String => (EmptyVal)IOAction
print_string("I'll repeat the line.")
  : (EmptyVal)IOAction
get_line
  : (String)IOAction
; 
  : (E)IsAnEnvAction ==> (E(A), E(B)) => E(B) 
print_string("I'll repeat the line.") ; get_line
  : (String)IOAction
  where (IOAction)IsAnEnvAction is true, E = IOAction, A = EmptyVal, B = String
;>
  : (E)IsAnEnvAction ==> (E(A), A => E(B)) => E(B) 
print_string("I'll repeat the line.") ; get_line ;> print_string
  : (EmptyVal)IOAction
  where (IOAction)IsAnEnvAction is true, E = IOAction, A = String, B = EmptyVal
\end{verbatim}

\paragraph{Example program}
\begin{verbatim}
main
  : (EmptyVal)IOAction
  = print_string <- "Hello! What's your name?" ; get_line ;> name =>
    print_string("Oh hi " + name + "! What's your age?") ; get_line ;> age =>
    print_string("Oh that's crazy " + name + "! I didn't expect you to be " + age + "!");
\end{verbatim}
In this bigger but similar example the types are:
\begin{verbatim}
print_string
  : String => (EmptyVal)IOAction
get_line
  : (String)IOAction

print_string <- "Hello! ... "
  : (EmptyVal)IOAction
print_string("Oh hi...)
  : (EmptyVal)IOAction
print_string("Oh that's crazy...)
  : (EmptyVal)IOAction

;
  : (E)IsAnEnvAction ==> (E(A), E(B)) => E(B) 

print_string("Oh hi...) ; get_line
  : (String)IOAction
  where (IOAction)IsAnEnvAction is true, E = IOAction, A = EmptyVal, B = String

age => print_string("Oh that's crazy...)
  : String => (EmptyVal)IOAction

;>
  : (E)IsAnEnvAction ==> (E(A), A => E(B)) => E(B) 

print_string("Oh hi...) ; get_line ;> age =>
print_string("Oh that's crazy...)
  : (EmptyVal)IOAction
  where (IOAction)IsAnEnvAction is true, E = IOAction, A = String, B = EmptyVal

print_string <- "Hello..." ; get_line
  : (String)IOAction

name => print_string("Oh hi ... (till the end)
  : String => (EmptyVal)IOAction

print_string <- "Hello..." ; get_line ;> name =>
print_string("Oh hi ... (till the end)
  : (EmptyVal)IOAction
\end{verbatim}
Therefore, "\texttt{main\ :\ (EmptyVal)IOAction}" checks out.  The key here is
to remember that function expressions extend to the end of the whole
expression. Therefore, we have "\texttt{name => ... (till the end)}" and
"\texttt{age => ... (till the end)}" as the second arguments of the two
occurences of the "\texttt{;>}" operator. 

\paragraph{Description}\pend
The environment action operators are used to combine values that do environment
actions into values that do more complicated environment actions. Environment
actions are also represented by types. More acurately, type constructors that
take a type as an argument and produce a new type (just like ListOf()s). A
value of the type \texttt{E(A)} where \texttt{(E)IsAnEnvAction} does an
environment action of type \texttt{E} that produces value of type \texttt{A}.
\\\\
The effect of the "\texttt{;}" operator described in words is the following:
given a value of type \texttt{E(A)} and a value of type \texttt{E(B)} (which
do environment actions that produce values of type \texttt{A} and \texttt{B}
respectively), create a new value the does both actions (provided the first did
not result in an error).  The overall effect is a value that does an
environment action of type \texttt{E} (the combination of the "smaller"
actions) which produces a value of type \texttt{B} (the one produced by the second
action) and therefore it is of type \texttt{E(B)}.
\\\\
Note that the value of type \texttt{A} produced by the first action is not used
anywhere. This happens mostly when \texttt{A = EmptyVal} and it is 
because values of type \texttt{E(EmptyVal)} are used for their environment
action only \\(e.g. \texttt{print_string(...)\ :\ (EmptyVal)IOAction}).
\\\\
How the two environment actions of the \texttt{E(A)} and \texttt{E(B)} values
are combined to produce the new environment action is specific to the
environment action type \texttt{E}.
\\\\
The effect of the "\texttt{;>}" operator described in words is the following:
given a value of type \texttt{E(A)} (which does an environment action of type
\texttt{E} that produces a value of type \texttt{A}) and a value of type
\texttt{A => E(B)} (which is a function that takes a value of type \texttt{A}
and returns an environment action of type \texttt{E} that produces a value
of type \texttt{B}), combine those two values by creating a value that does the
following: 
\begin{itemize}
\item
Performs the first action that produces a value of type \texttt{A}

\item
Takes the value of type \texttt{A} produced (provided there was no error) and
passes it to the function of type \texttt{A => E(B)} that then returns an
action

\item
Perfoms the resulting action 
\end{itemize}
The overall effect is an environment action  of type \texttt{E} that at the end
produces a value is of type \texttt{B} and therefore the new value is of type
\texttt{E(B)}.

\subsubsection{Operator Expressions}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
1 + 2
1 + x * 3 ^ y
"Hello " + "World!"
x -> f -> g
f o> g o> h
x = y
x >= y - z & x < 2 * y
get_line ; get_line ;> line => print("Second line: " + line)
\end{verbatim}

\item \textit{Description}\\\\
Operator expressions are expressions that use operators. Operators act like
two-argument-functions that are placed in between their arguments. Therefore,
they have function types and they act as it is described in their respective
sections above this one.
\\\\
An operator expression might have multiple operators. The order of operations
is explained in the next section ("Complete Table, Precedence and Associativity")
in Table \ref{table:precassoc}.
\\\\
Just like functions, the sub-expressions
that act as arguments to an operator, must have types that match the types 
expected by the operator.
\\\\
It is possible to end an operator expression with a function. This is mostly
useful with the "\texttt{;>}" operator (see previous section: "Environment
Operators"), but it is also possible with the following operators:
"\texttt{->}", "\texttt{o>}", "\texttt{<o}".

\item \textit{Big Operator Expressions}\\\\
It is possible to stretch a (big) operator expression over multiple lines.
In that case:
\begin{itemize}
\item
The operator expression must split in a new line after an operator (not an
argument).

\item
Every line after the first must be indented so that in begins at the column 
where the first character of the operator expression was in the first line.

\item
The precise indentation rules are described in the section
"Indentation System" \ref{subsubsec:indsys}.
\end{itemize}

\item \textit{Grammar}
\begin{grammar}
<op-expr> ::=
<simple-op-expr> | <op-expr-func-end> | <big-op-expr> | <cases-op-expr>
\\

<simple-op-expr> ::=  <op-arg> ( `\ ' <op>  `\ ' <op-arg> )+

<op-expr-func-end> ::= <simple-op-expr> `\ '  <op> `\ ' <simple-func-expr>

<big-op-expr> ::= ""\\
<op-expr-line> ( `\\n' <indent> <op-expr-line> )* \\
`\\n' <indent>
( <op-arg> | <simple-op-expr> |
  [ <op-expr-line> `\ ' ] ( <simple-func-expr> | <big-func-expr>)
)

<cases-op-expr> ::=
<op-expr-line> ( `\\n' <indent> <op-expr-line> )*
( `\\n' <indent> | `\ ' ) <cases-func-expr> 

<op-expr-line> ::= ( <op-arg> | <simple-op-expr> ) `\ ' <op> 
\\

<op-arg> ::= <no-paren-op-arg> | <paren-expr>

<no-paren-op-arg> ::= <basic-expr> | <pre-func> | <post-func> | <pre-func-app>

<op> ::= 
`->' | `<-' | `o>' | `<o' | `^' | `*' | `/' | `+' | `-' |
`=' | `/=' | `>' | `<' | `>=' | `<=' | `\&' | `|' | `;>' | `;'\\
\end{grammar}
\end{itemize}

\subsubsection{Complete Table, Precedence and Associativity}
\begin{table}[h!]

\caption{
The complete table of lcases operators along with their types and 
their short descriptions.
}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type & Description \\ 
\hline
\hline
\texttt{->} & (A, A \ra B) \ra B & Right function application \\
\hline
\texttt{<-} & (A \ra B, A) \ra B & Left function application \\
\hline
\texttt{o>} & (A \ra B, B \ra C) \ra (A \ra C) & Right function composition \\
\hline
\texttt{<o} & (B \ra C, A \ra B) \ra (A \ra C) & Left function composition \\
\hline
\texttt{\^} & (A)ToThe(B)HasType(C) \Ra (A, B) \ra C & General exponentiation  \\
\hline
\texttt{*} & (A)And(B)MultiplyTo(C) \Ra (A, B) \ra C & General multiplication  \\
\hline
\texttt{/} & (A)Divides(B)To(C) \Ra (B, A) \ra C & General division \\
\hline
\texttt{+} & (A)And(B)AddTo(C) \Ra (A, B) \ra C & General addition \\ 
\hline
\texttt{-} & (A)SubtractsFrom(B)To(C) \Ra (B, A) \ra C & General subtraction \\
\hline
\texttt{= /=} & (A)HasEquality \Ra (A, A) \ra Bool & Equality operators \\
\hline
\texttt{>= <=} & (A)HasOrder \Ra (A, A) \ra Bool & Order operators \\
\hline
\texttt{> <} & (A)And(B)AreComparable \Ra (A, B) \ra Bool & Comparison operators\\
\hline
\texttt{\& |} & (Bool, Bool) \ra Bool & Boolean operators \\
\hline
\texttt{;>} & (E)IsAnEnvAction \Ra (E(A), A \ra E(B)) \ra E(B) &
Monad bind \\
\hline
\texttt{;} & (E)IsAnEnvAction \Ra (E(A), E(B)) \ra E(B) &
Monad then \\
\hline
\end{tabular}
\end{center}

\label{table:allops}

\end{table}\mbox{}\\
The order of operations is done from highest to lowest precedence. In the same
level of precedence the order is done from left to right if the associativity
is "Left" and from right to left if the associativity is "Right". For the
operators that have associativity "None" it is not allowed to place them in the
same operator expression. The precedence and assosiativity of the operators
is shown in the table below.
\begin{table}[h!]

\caption{ The table of precedence and associativity of the lcases operators.  }

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Precedence & Associativity \\ 
\hline
\hline
\texttt{->} & 10 (highest) & Left \\
\hline
\texttt{<-} & 9 & Right \\
\hline
\texttt{o> <o} & 8 & Left \\
\hline
\texttt{\^} & 7 & Right \\
\hline
\texttt{* /} & 6 & Left \\
\hline
\texttt{+ -} & 5 & Left \\ 
\hline
\texttt{= /= > < >= <=} & 4 & None \\
\hline
\texttt{\&} & 3 & Left \\
\hline
\texttt{|} & 2 & Left \\
\hline
\texttt{;> ;} & 1 & Left \\
\hline
\end{tabular}
\end{center}

\label{table:precassoc}

\end{table}

\newpage
\subsection{Function Expressions}
\label{subsec:funcexprs}

\begin{grammar}
<func-expr> ::= <simple-func-expr> | <big-func-expr> | <cases-func-expr>
\end{grammar}

\subsubsection{Regular Function Expressions}

\begin{itemize}
\item \textit{Examples}

\begin{verbatim}
a => 17 * a + 42

(x, y, z) => (x ^ 2 + y ^ 2 + z ^ 2) ^ (1 / 2)
\end{verbatim}

\item \textit{Description}\\\\
Regular function expressions are used to define functions or be part of bigger
expressions as anonymous functions. They are comprised by their parameters and
their body. Parameter are specified by identifiers. The parameters are either
only one, in which case there is no parenthesis, or they are many, in which
case they are in parenthesis, seperated by commas. The parameters and the body
are seperated by an arrow (" \texttt{=>} "). The body is an operator
expression.

\item \textit{Big Function Expressions}\\\\
It is possible to stretch a (big) function expression over multiple lines.
In that case:
\begin{itemize}
\item
The function expression must split in a new line after the arrow
("\texttt{=>}") following the parameters.

\item
Every line after the first must be indented so that in begins at the column 
where the first character of the parameters was in the first line.

\item
The precise indentation rules are described in the section
"Indentation System" \ref{subsubsec:indsys}.
\end{itemize}

\item \textit{Grammar}
\begin{grammar}
<simple-func-expr> ::=
<parameters> `\ =>\ ' <simple-func-body>

<big-func-expr> ::=
<parameters> `\ =>\\n' <indent> ( <simple-func-body> | <big-op-expr> )
\\

<parameters> ::= <identifier> | `(' <identifier> ( `,\ ' <identifier> )+ `)'

<simple-func-body> ::= <no-paren-op-arg> | <simple-op-expr> | <op-expr-func-end>
\end{grammar}
\end{itemize}

\subsubsection{"cases" Function Expressions}
\label{subsubsec:casessyntax}

\begin{itemize}
\item \textit{Examples}

\begin{verbatim}
print_sentimental_bool
  : Bool => (EmptyVal)IOAction
  = cases =>
    true => print <- "It's true!! :)"
    false => print <- "It's false... :("

or_type TrafficLight
values green | amber | red

print_sentimental_traffic_light
  : TrafficLight => (EmptyVal)IOAction
  = cases =>
    green => print <- "It's green! Let's go!!! :)"
    amber => print <- "Go go go, fast!"
    red => print <- "Stop right now! You're going to kill us!!"

is_not_red
  : TrafficLight => Bool
  = cases =>
    green => true
    amber => true
    red => false

is_seventeen_or_forty_two
  : Int => Bool
  = cases => 
    17 => true
    42 => true
    ... => false
 
traffic_lights_match
  : (TrafficLight, TrafficLight) => Bool
  = (cases, cases) =>
    (green, green) => true
    (amber, amber) => true
    (red, red) => true
    ... => false

gcd
  : (Int, Int) => Int
  = (x, cases) =>
    0 => x
    y => gcd(y, x -> mod <- y) 

is_empty
  : ListOf(A)s => Bool
  = cases => 
    empty => true
    non_empty:anything => false

apply()to_all
  : (A => B, ListOf(A)s) => ListOf(B)s
  = (f, cases) =>
    empty => empty
    non_empty:list => non_empty:(f <- list.head, apply(f)to_all <- list.tail)

\end{verbatim}

\item \textit{Description}\\\\
"cases" is a keyword that works as a special parameter. The difference is that
instead of giving the name "cases" to that parameter, it allows the programmer
to pattern match on the possible values of that parameter and return a
different result for each particular case. 
\\\\
The "cases" keyword can only be used on parameters that have either one of the 
basic types (Int, Real, Char, String) or an or\_type (e.g. Bool, ListOf(A)s).
\\\\
The last case can be "\texttt{... => (body of default case)}" to capture all
remaining cases while dismissing the value (e.g.
\texttt{is_seventeen_or_forty_two} example), or it can be
"\texttt{some_id => (body of default case)}" to capture all remaining
cases while being able to use the value with the name "\texttt{some_id}"
(e.g.  "y" in \texttt{gcd} example).
\\\\
It is possible to use the "cases" keyword in multiple parameters to match on all
of them. By doing that, each case represents a particular combination of values
for the parameters involved\\(e.g. \texttt{traffic_lights_match} example).
\\\\
It is also possible to use a "where" expression below a particular case. The
"where" expression must be indented two spaces more than than the line where
that particular case begins.
\\\\
A function expression that uses the "cases" syntax must contain the "cases"
keyword in at least one parameter. The number of matching expressions in 
all cases must be the same as the number of parameters with the "cases" keyword.

\item \textit{Grammar}
\begin{grammar}
<cases-func-expr> ::= <cases-parameters> `\ =>' <case>+ <end-case> 

<cases-parameters> ::=
<cases-parameter> | `(' <cases-parameter> ( `,\ ' <cases-parameter> )+ `)'

<cases-parameter> ::= <parameter> | `cases' \\

<case> ::=  `\\n' <indent> <matching> `\ =>' <case-body>

<end-case> ::=
`\\n' <indent> ( `...' | <matching> ) `\ =>' <case-body>\\

<matching> ::= 
<literal> | <identifier> | <pre-func> <matching> | <tuple-matching> |
<list-matching>

<tuple-matching> ::= `(' <matching> ( `,' <matching> )+ `)'

<list-matching> ::= `[' [ <matching> ( `,' <matching> )* [ `, ...' ] ] `]' \\


<case-body> ::=
( <simple-func-body> | <big-op-expr> ) [ <where-expr> ]
\end{grammar}

\end{itemize}

\subsection{Value Definitions and  "where" Expressions}
\label{subsec:valdefswhere}

\subsubsection{Value Definitions}
\label{subsubsec:valdefs}

\begin{itemize}

\item \textit{Examples}

\begin{verbatim}
foo
  : Int
  = 42

val1, val2, val3
  : Int, Bool, Char
  = 42, true, 'a'

int1, int2, int3
  : all Int
  = 1, 2, 3

f
  : (Int, Int, Int) => Int
  = (a, b, c) => a + b * c
\end{verbatim}

\item \textit{Description}\\\\
Value definitions are the main building block of lcases programs. To define a
new value you give it a name, a type and an expression. The name is in the
first line. The second line is indented two spaces more and begins by ": " and
continues with the type expression. The third line is indented as the second,
begins by \\ "= " and continues with the value expression (which extends to as
many lines as needed).
\\\\
A value definition is either in the first column, where it can be "seen" by all
other value definitions, or it is in a "where" expression (see section below),
where it can be "seen" by the expression above the "where" and all the other
definitions in the same "where" expression.
\\\\
A value definition can be followed by a "where" expression where intermediate
values used in the value expression are defined. In that case, the "where"
expression must be indented two spaces more than the "=" line of the value
definition.
\\\\
It is possible to group value definitions together by seperating the names, the
types and the expressions with commas. This is very useful for not cluttering
the program with many definitions for values with small expressions (e.g.
constants).  When grouping definitions together it is also possible to use the
keyword "all" to give the same type to all the values.

\item \textit{Grammar}
\begin{grammar}
<value-def> ::= 
<indent> <identifier> 
`\\n' <indent> `:\ ' <type> 
`\\n' <indent> `=\ ' <value-expr> [ <where-expr> ]

<value-expr> ::=
<no-paren-op-arg> | <op-expr> | <func-expr> | <big-tuple> | <big-list>

<grouped-value-defs> ::= ""\\
<indent> <identifier> ( `,\ ' <identifier> )+ \\
`\\n' <indent> `:\ ' ( <type> ( `,\ ' <type> )+ | `all' <type> ) \\
`\\n' <indent> `=\ '
<comma-sep-line-exprs> ( `\\n' <indent> `,' <comma-sep-line-exprs> )*
\end{grammar}

\end{itemize}

\subsubsection{"where" Expressions}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
sort :
  (A)HasOrder ==> ListOf(A)s => ListOf(A)s
  = cases => 
    empty => empty
    non_empty:l => sort(less_l) + l.head + sort(greater_l)
      where
      less_l, greater_l
        : all ListOf(A)s
        = filter_with(x => x < l.head, l.tail)
        , filter_with(x => x >= l.head, l.tail)

tuple_type Coeffs
value (previous, current) : Int x Int

tuple_type GcdAndCoeffs
value (gcd, a, b) : Int x Int x Int

ext_euc
  : (Int, Int) => GcdAndCoeffs
  = ext_euc_rec((1, 0), (0, 1))

ext_euc_rec
  : (Coeffs, Coeffs, Int, Int) => GcdAndCoeffs
  = (a_coeffs, b_coeffs, x, cases) =>
    0 => (x, a_coeffs.previous, b_coeffs.previous)
    y => ext_euc_rec(next <- a_coeffs, next <- b_coeffs, y, x -> mod <- y)
      where
      next: Coeffs => Coeffs
        = cs => (cs.current, cs.previous - x / y * cs.current)

big_string
  : String
  = s1 + s2 + s3 + s4
    where
    s1, s2, s3, s4 : all String
      = "Hello, my name is Struggling Programmer."
      , "I have tried way too many times to fit a big chunk of text"
      , "inside my program, without it hitting the half-screen mark!"
      , "I am so glad I finally discovered lcases!!!"
\end{verbatim}

\item \textit{Description}\\\\
"where" expressions allow the programmer to use values inside an expression and
define them below it. They are very useful for reusing or abbreviating
expressions that are specific to a particular definition or case.
\\\\
A "where" expression begins by a line that only has word "where" in it. It is
indented as described in the "Value Definitions" (\ref{subsubsec:valdefs}) or
"'cases' Function Expressions" (\ref{subsubsec:casessyntax}) section according
to which of the two is above it.  The definitions are placed below the "where"
line and must have the same indentation. 

\item \textit{Grammar}
\begin{grammar}
<where-expr> ::=
`\\n' <indent> `where\\n' ( <value-def> | <grouped-value-defs> )+
\end{grammar}

\end{itemize}

\subsection{Indentation and Complete Grammar for Values}

\subsubsection{Indentation System}
\label{subsubsec:indsys}

The \textit{$<$indent$>$} nonterminal in not a normal BNF nonterminal. It is a
context sensitive construct that enforces the indentation rules of lcases.
It depends on a integer value that shall be named "indentation level" ($il$).
The \textit{$<$indent$>$} nonterminal corresponds to $2*il$ space characters.
The indentation level follows the rules below:

\paragraph{Indentation Rules}
\begin{itemize}

\item
At the beginnng: $il = 0$.

\item
At the end of the first line of a value definition: $il \leftarrow il + 1$.
This also applies to grouped value definitions.

\item
At the end of the third line ("=" line) of a (single) value definition: $il
\leftarrow il + 1$.

\item
At the end of a (single) value definition: $il \leftarrow il - 2$.

\item
At the end of grouped value definitions: $il \leftarrow il - 1$.

\item
After the "\texttt{=>}" arrow in a case: $il \leftarrow il + 1$.

\item
At the end of a case body: $il \leftarrow il - 1$.

\item
In a cases function expression which does not begin in the "=" line of a value
definition:
  \begin{itemize}

  \item
  After the arrow "\texttt{=>}" at the end of the paremeters: $il \leftarrow il + 1$.

  \item
  At the end of the whole cases function expression: $il \leftarrow il - 1$.

  \end{itemize}

\end{itemize}

\subsubsection{Complete Grammar for Values}
\begin{grammar}

<literal> ::= <literal> \\

<identifier> ::= [a-z] [a-z_]* ( `()' [a-z_]+ )* [ [0-9] ] \\

<paren-expr> ::= `(' <op-or-func-expr> `)'  

<op-or-func-expr> ::=
<simple-op-expr> | <op-expr-func-end> | <simple-func-expr>  \\

<tuple> ::= `(' <line-expr> `,\ ' <comma-sep-line-exprs> `)'

<comma-sep-line-exprs> ::= <line-expr> ( `,\ ' <line-expr> )*

<line-expr> ::= <no-paren-op-arg> | <op-or-func-expr> \\

<big-tuple> ::= ""\\
`(' <line-expr> [ `\\n' <indent> ] `,\ ' <comma-sep-line-exprs> \\
( `\\n' <indent> `,' <comma-sep-line-exprs> )* \\
`\\n' <indent> `)' \\

<list> ::= `[' [ <comma-sep-line-exprs> ] `]'

<big-list> ::= 
`[' <comma-sep-line-exprs>
( `\\n' <indent> `,' <comma-sep-line-exprs> )*
`\\n' <indent> `]' \\

<paren-func-app> ::= ""\\""
[ <arguments> ] <identifier-with-arguments> [ <arguments> ]
\alt " "<arguments> <identifier> [ <arguments> ]
\alt " "<identifier> <arguments>

<arguments> ::= `(' <comma-sep-line-exprs> `)'

<identifier-with-arguments> ::= ""\\""
[a-z] [a-z_]* ( `()'[a-z_]+ )* <arguments>
[a-z_]+ ( ( `()' | <arguments> ) [a-z_]+ )* 
[ [0-9] ] \\

<pre-func> ::= <identifier> `:'

<pre-func-app> ::= <pre-func> ( <basic-expr> | <paren-expr> | <pre-func-app> )

<basic-expr> ::=
<literal> | <identifier> | <tuple> | <list> | <paren-func-app> | <post-func-app> \\

<post-func> ::= `.' <identifier>

<post-func-app> ::= ( <paren-expr> | <basic-expr> ) <post-func> \\

<op-expr> ::=
<simple-op-expr> | <op-expr-func-end> | <big-op-expr> | <cases-op-expr>
\\

<simple-op-expr> ::=  <op-arg> ( `\ ' <op>  `\ ' <op-arg> )+

<op-expr-func-end> ::= <simple-op-expr> `\ '  <op> `\ ' <simple-func-expr>

<big-op-expr> ::= ""\\
<op-expr-line> ( `\\n' <indent> <op-expr-line> )* \\
`\\n' <indent>
( <op-arg> | <simple-op-expr> |
  [ <op-expr-line> `\ ' ] ( <simple-func-expr> | <big-func-expr>)
)

<cases-op-expr> ::=
<op-expr-line> ( `\\n' <indent> <op-expr-line> )*
( `\\n' <indent> | `\ ' ) <cases-func-expr> 

<op-expr-line> ::= ( <op-arg> | <simple-op-expr> ) `\ ' <op> 
\\

<op-arg> ::= <no-paren-op-arg> | <paren-expr>

<no-paren-op-arg> ::= <basic-expr> | <pre-func> | <post-func> | <pre-func-app>

<op> ::= 
`->' | `<-' | `o>' | `<o' | `^' | `*' | `/' | `+' | `-' |
`=' | `/=' | `>' | `<' | `>=' | `<=' | `\&' | `|' | `;>' | `;'\\

<func-expr> ::= <simple-func-expr> | <big-func-expr> | <cases-func-expr> \\

<simple-func-expr> ::= <parameters> `\ =>\ ' <simple-func-body>

<big-func-expr> ::=
<parameters> `\ =>\\n' <indent> ( <simple-func-body> | <big-op-expr> )
\\

<parameters> ::= <identifier> | `(' <identifier> ( `,\ ' <identifier> )+ `)'

<simple-func-body> ::= <no-paren-op-arg> | <simple-op-expr> | <op-expr-func-end> \\

<cases-func-expr> ::= <cases-parameters> `\ =>' <case>+ <end-case> 

<cases-parameters> ::=
<cases-parameter> | `(' <cases-parameter> ( `,\ ' <cases-parameter> )+ `)'

<cases-parameter> ::= <parameter> | `cases' \\

<case> ::=  `\\n' <indent> <matching> `\ =>' <case-body>

<end-case> ::=
`\\n' <indent> ( `...' | <matching> ) `\ =>' <case-body>\\

<matching> ::= 
<literal> | <identifier> | <pre-func> <matching> | <tuple-matching> |
<list-matching>

<tuple-matching> ::= `(' <matching> ( `,' <matching> )+ `)'

<list-matching> ::= `[' [ <matching> ( `,' <matching> )* [ `, ...' ] ] `]' \\

<case-body> ::=
( `\ ' | `\\n' <indent> ) ( <simple-func-body> | <big-op-expr> ) [ <where-expr> ]\\

<value-def> ::= 
<indent> <identifier> 
`\\n' <indent> `:\ ' <type> 
`\\n' <indent> `=\ ' <value-expr> [ <where-expr> ]

<value-expr> ::=
<no-paren-op-arg> | <op-expr> | <func-expr> | <big-tuple> | <big-list>

<grouped-value-defs> ::= ""\\
<indent> <identifier> ( `,\ ' <identifier> )+ \\
`\\n' <indent> `:\ ' ( <type> ( `,\ ' <type> )+ | `all' <type> ) \\
`\\n' <indent> `=\ '
<comma-sep-line-exprs> ( `\\n' <indent> `,' <comma-sep-line-exprs> )* \\

<where-expr> ::=
`\\n' <indent> `where\\n' ( <value-def> | <grouped-value-defs> )+ \\
\end{grammar}


\section{Language Description: Types and Type Logic}

\subsection{Types}
\label{subsec:types}

The constructs regarding types are two: \textbf{type expressions} and
\textbf{type definitions}.
\\\\
Type expressions are divided into the following categories:
\begin{itemize}
\item Type Identifiers
\item Type Variables
\item Function Types
\item Product Types
\item Type Application Types
\item Conditional Types
\end{itemize}
which are described in the following section.
\\\\
The grammar of a type expression is:
\begin{grammar}
<type> ::= [ <condition> ]  <simple-type> 

<simple-type> ::= <type-id> | <type-var> | <func-type> | <prod-type> | <type-app>
\\
\end{grammar}
Type definitions are divided into \texttt{tuple_type} definitions and
\texttt{or_type} definitions which are described in the sections
\ref{subsubsec:tupts} and \ref{subsubsec:orts} respectively.
\\\\
The grammar of a type definition is:
\begin{grammar}
<type-def> ::= <tuple-type-def> | <or-type-def>
\end{grammar}

\subsubsection{Type Expressions}

\paragraph{Type Identifiers}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
Int
Real 
Char 
String
FunnyType
MyDefinedType
\end{verbatim}

\item \textit{Description} \\\\
A type identifier is either the name of a basic type (Int, Real, Char, String) or
the name of some defined type that has no type parameters. It begins with a capital
letter and is followed by one or more capital or lowercase letters.

\item \textit{Grammar}
\begin{grammar}
<type-id> ::= [A-Z] [A-Za-z]+ \\ 
\end{grammar}
\end{itemize}

\paragraph{Type Variables}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
A
B
C
X 
Y
Z
\end{verbatim}

\item \textit{Examples of type variables inside bigger type expressions}
\begin{verbatim}
A => A
(A => B, B => C) => (A => C)
((A, A) => A, A, ListOf(A)s) => A
\end{verbatim}

\item \textit{Description} \\\\
Type Variables are used inside larger type expressions of polymorphic types. A
polymorphic type is a type where any function of that type can be used as a
function of any type that corresponds to substituting every type variable of
the polymorphic type with a particular type. The easiest example of a
polymorphic type is the type of the identity function where we have:
\begin{verbatim}
id
  : A => A
  = x => x

id(1)
  : Int
  where A is substituted by Int and id gets the type Int => Int

id("Hello")
  : String
  where A is substituted by String and id gets the type String => String
\end{verbatim}

A type variable is a single capital letter.

\item \textit{Grammar}
\begin{grammar}
<type-var> ::= [A-Z] \\ 
\end{grammar}
\end{itemize}

\paragraph{Function Types}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
String => String 
Real => Int
A => A
Int x Int => Int
(Real, Real, Real) => Real
(A => B, B => C) => (A => C)
(Int => Int) => Int
\end{verbatim}

\item \textit{Description} \\\\
A function type expression is comprised of the expressions of the types of the
parameters and the expression of the type of the result, seperated by the arrow
"\texttt{=>}". If there are more than one parameters, the expressions of their
types are inside parentheses and seperated by commas. If there is only one
parameter, the expression of its type is put in parentheses only if it is 
a function type. The same applies to the type of the result.

\item \textit{Grammar}
\begin{grammar}
<func-type> ::= <param-types-expr> `\ =>\ ' <one-type>

<param-types-expr> ::= <one-type> | `(' <simple-type> ( `, ' <simple-type> )+ `)'

<one-type> ::=
<type-id> | <type-var> | <prod-type> | <type-app> | `(' <func-type> `)'
\end{grammar}
\end{itemize}

\paragraph{Product Types}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
Int x Int
Real x Real x Real
Int x Real x String
ListOf(Int)s x (Int x ListOf(String)s)
(Int => Int) x (Int x Real) x (Real => String)
\end{verbatim}

\item \textit{Description} \\\\
Product types are the types of tuples. They are comprised of the expressions of
the types of the fields seperated by the string " x " (space 'x' space) because
'x' is very similar the symbol used in the cartesian product. If any of the
fields has a product or a function type then the corresponding type expression
must be inside parentheses.
\item \textit{Grammar}
\begin{grammar}
<prod-type> ::= <field-type> ( `\ x\ ' <field-type> )+

<field-type> ::=
<type-id> | <type-var> | <type-app> | `(' ( <func-type> | <prod-type> ) `)'
\end{grammar}
\end{itemize}

\paragraph{Type Application Types}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
Possibly(Int)
ListOf(Real)s
TreeOf(String)s 
Error(String)OrResult(Int)
ListOf(Int => Int)s
ListOf(A)s
\end{verbatim}

\item \textit{Description} \\\\
Type application types are types that are produced by passing arguments
to a type function generated by a \texttt{tuple_type} or an \texttt{or_type}
definition. For example, given the definition of \texttt{ListOf(A)s}:
\begin{verbatim}
or_type ListOf(A)s
values non_empty:NonEmptyListOf(A)s | empty
\end{verbatim}
We have that \texttt{ListOf()s} is a type function that receives one type parameter
and returns a resulting type. For example \texttt{ListOf(Int)s} is the result
of passing the type argument \texttt{Int} to \texttt{ListOf()s}.
\\\\
Type application types have the same form as the name in the
\texttt{tuple_type} or \texttt{or_type} definition, with the difference that
any of the type parameters can be substituted with an argument type expression.

\item \textit{Grammar}
\begin{grammar}
<type-app> ::= ""\\""
[ <types-in-paren> ] <type-id-with-args> [ <types-in-paren> ]
\alt " "<types-in-paren> <type-id> [ <types-in-paren> ]
\alt " "<type-id> <types-in-paren>

<type-id-with-args> ::= 
<type-id> ( <types-in-paren> [A-Za-z]+ )+

<types-in-paren> ::= `(' <simple-type> ( `, ' <simple-type> )* `)'
\end{grammar}
\end{itemize}

\paragraph{Conditional Types}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
(A)HasEquality ==> (A, A) => Bool
(A)And(B)AddTo(C) ==> (A, B) => C
(A)Is(B)sFirst ==> B => A
(T)HasStringRepr ==> T => String
(E)IsAnEnvAction ==> (E(A), A => E(B)) => E(B)
\end{verbatim}

\item \textit{Description} \\\\
Conditional types are the types of values that are polymorphic not because of
their structure but because they have been defined (seperately) for many
different combinations of types (a.k.a. ad hoc polymorphism). They are
comprised of a condition and a "simple" type (i.e. a type without a
condition) which are seperated by the arrow "\texttt{==>}". The condition is a
type proposition which refers to the type variables inside the "simple" type
and it must hold whenever the polymorphic value of that type is used. For
example:
\begin{verbatim}
get_first
  : (A)Is(B)sFirst => B => A
\end{verbatim}
can be used as follows:
\begin{verbatim}
pair, triple, list
  : Int x String, Real x Char x Int, ListOf(String)s
  = (42, "The answer to everything"), (3.14, 'a', 1), ["Hi!", "Hello", Heeey"]

>> pair -> get_first
  : Int
  = 42
>> triple -> get_first
  : Real
  = 3.14
>> list -> get_first
  : String
  = "Hi!"
\end{verbatim}
and that is because the following propositions hold:
\begin{verbatim}
(Int)Is(Int x String)sFirst
(Real)Is(Real x Char x Int)sFirst
(String)Is(ListOf(String)s)sFirst
\end{verbatim}
which it turn means that the function \texttt{get_first} has been defined
for these combinations of types. For more on how conditions, propositions and
ad hoc polymorphism works, see the "Type Logic" section (\ref{subsec:typelogic}).

\item \textit{Grammar}\\\\
As described in the beginning of this "Types" section the grammar of a type is:
\begin{grammar}
<type> ::= [ <condition> ]  <simple-type> 

<simple-type> ::= <type-id> | <type-var> | <func-type> | <prod-type> | <type-app>
\end{grammar}
And therefore here only the grammar of the condition must be written:
\begin{grammar}
<condition> ::= <proposition> `\ ==>\ ' 
\end{grammar}
\end{itemize}

\subsubsection{Type Definitions: Tuple Types}
\label{subsubsec:tupts}

\paragraph{Example Definitions}

\begin{verbatim}
tuple_type Name
value (first_name, last_name) : String x String

tuple_type Date
value (day, month, year) : Int x Int x Int

tuple_type MathematicianInfo
value (name, nationality, date_of_birth) : Name x String x Date

tuple_type TreeOf(A)s
values (root, subtrees) : A x ListOf(TreeOf(A)s)s

tuple_type Indexed(T)
value (index, val) : Int x T
\end{verbatim}

\paragraph{Usage Examples}

\begin{verbatim}
euler_info
  : MathematicianInfo
  = (("Leonhard", "Euler"), "Swiss", (15, 4, 1707))

name_to_string
  : Name => String
  = n => "\nFirst Name: " + n.first_name + "\nLast Name: " + n.last_name

print_name_and_nationality
  : ClientInfo => (EmptyVal)IOAction
  = ci => print(ci.name -> name_to_string + "\nNationality: " + ci.nationality)

sum_nodes
  : TreeOf(Int)s => Int
  = tree => tree.root + tree.subtrees -> apply(sum_nodes)to_all -> sum_list
\end{verbatim}

\paragraph{Description}\pend
A tuple type is equivalent to a product type with a new name  and names for the
fields for convinience. A tuple type generates postfix functions for all of
the fields by using a '.' before the name of the field. For example the
\texttt{MathematicianInfo} type above generates the following functions:
\begin{verbatim}
.name
  : MathematicianInfo => Name
.nationality
  : MathematicianInfo => String
.date_of_birth
  : MathematicianInfo => Date
\end{verbatim}
These functions are named "postfix functions" because they can be appended to
their argument.

\paragraph{Definition Grammar}
\begin{grammar}
<tuple-type-def> ::= 
`tuple_type\ ' <type-name>
`\\nvalue\ ' `(' <identifier> (`,\ ' <identifier>)* `)' `\ :\ ' <prod-type>

<type-name> ::= 
[ <params-in-paren> ] ( <type-id> | <type-id-with-params> ) [ <params-in-paren> ]

<type-id-with-params> ::= 
<type-id> ( <params-in-paren> [A-Za-z]+ )+

<params-in-paren> ::= `(' <type-var> ( `, ' <type-var> )* `)'
\end{grammar}

\subsubsection{Type Definitions: Or Types}
\label{subsubsec:orts}

\paragraph{Examples}

\begin{verbatim}
or_type Bool
values true | false

or_type Possibly(A)
values the_value:A | no_value

// needed tuple_type for ListOf(A)s
tuple_type NonEmptyListOf(A)s
value (head, tail) : A x ListOf(A)s

or_type ListOf(A)s
values non_empty:NonEmptyListOf(A)s | empty

or_type Error(A)OrResult(B)
values error:A | result:B
\end{verbatim}

\paragraph{Usage}

\begin{verbatim}
is_empty
  : ListOf(A)s => Bool
  = cases => 
    empty => true
    non_empty:anything => false

get_head
  : ListOf(A)s => Possibly(A)
  = cases => 
    empty => no_value
    non_empty:list => the_value:list.head

sum_list
  : ListOf(Int)s => Int
  = cases
    empty => 0
    non_empty:l => l.head + sum_list(l.tail)

print_err_or_res
  : Error(A)OrResult(B) => (EmptyVal)IOAction
  = cases => 
    error:e => print("Error occured: " + e -> to_string)
    result:r => print("All good! The result is: " + r -> to_string)
\end{verbatim}

\paragraph{Description}\pend
Values of an \texttt{or_type} are one of many cases. Some cases have other
values inside.  The cases which have other values inside are followed by a
semicolon and the type of the internal value. The same syntax can be used for
matching that particular case in a function using the "cases" syntax, with the
difference that after the colon, we write the name given to the value inside.
An \texttt{or_type} definition automatically creates prefix functions for each
case with an internal value.  For example, for the case "\texttt{non_empty}" of
a list, the function "\texttt{non_empty}:" is automatically created from the
definition for which we can say:
\begin{verbatim}
non_empty:
  : NonEmptyListOf(A)s => ListOf(A)s
\end{verbatim}
Similarly:
\begin{verbatim}
the_value:
  : A => Possibly(A)
\end{verbatim}
These functions are called "prefix functions" because they are prepended to their
argument.
For example:
\begin{verbatim}
non_empty_l
  : NonEmptyListOf(Int)s
  = (1, [2, 3, 4])
l
  : ListOf(Int)s
  = non_empty:non_empty_l
\end{verbatim}
These functions can be used like any other function as arguments to other functions.
For example:
\begin{verbatim}
non_empty_ls_to_ls
  : ListOf(NonEmptyListOf(A)s)s => ListOf(ListOf(A)s)s
  = apply(non_empty:)to_each
\end{verbatim}

\paragraph{Definition Grammar}
\begin{grammar}
<or-type-definition> ::= ""\\
`or_type\ ' <type-name> 
\\`\\nvalues\ ' <identifier> [ `:' <type> ] ( `\ |\ ' <identifier> [ `:' <type> ])*
\end{grammar}

\subsection{Type Logic}
\label{subsec:typelogic}

\subsubsection{Type Proposition}

\subsubsection{Type Theorem}

\section{Predefined}

\subsection{Constants}

\subsection{Functions}

\subsection{Types}

\subsection{Type Propositions}

\section{Parser implimentation}

The parser was implemented using the parsec library.

\subsection{AST Types}

\subsection{Parsers}

\section{Translation to \H}

\section{Running Examples}

\section{Conclusion}

%\newpage

%\paragraph{Examples}
%
%\begin{verbatim}
%\end{verbatim}

%\paragraph{Description}\pend
%desc

%\paragraph{Examples in \H}
%
%\begin{verbatim}
%\end{verbatim}

% \begin{tabular}{ |c|c| } 
% \hline
% 1 & 2 \\ 
% \hline
% \hline
% 1.1 & 1.2 \\ 
% \hline
% \end{tabular}

%  \includegraphics[width=10cm, height=8cm]{../Images/image.png}

\end{document}
