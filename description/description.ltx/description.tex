\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{syntax}
\usepackage{array}
\usepackage[left=2cm,right=2cm,top=2cm]{geometry}

\date{}
\author{
  Dimitris Saridakis
}

\def\imgs{../Images}
\def\H{Haskell}
\def\ra{\texttt{->}\ }
\def\Ra{\texttt{=>}\ }
%\newcommand\_[_]{_}

\renewcommand{\arraystretch}{1.5}

\begin{document}

\title{
\textbf{Lambda Cases}
}
\maketitle

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}
\tableofcontents

\section{Introduction}

\H\ is a delightful language. Yet, for some reason, it doesn't seem to have it's 
rightful place in terms of popularity in industry. Why is it so?
Is it inherently hard to learn
and therefore only the brave enough students and corporations dare to use it, or
could it be that the syntax is perplexing to the amateur eye? It is my belief that 
with some syntax changes that give a greater familiarity to the new user, there
would be no language more compelling than (the new) \H. In an attempt to achieve
that familiarity, I present some new syntax, of which
some is closer to the imperative/OOP style (to attract more already experienced
programmers from these languages), some is closer to mathematics (in which most 
programmers should be experienced) and some is closer to natural language
(in which we are all already experienced). Ofcourse, I could not rewrite \H\
from scratch by my self, so I will try to keep the language as small and to the 
point as possible for now, as well as use as much as I can from \H\ itself, as 
the new language (Lambda Cases) is compiled to \H.

\section{Language Description}

\subsection{Values}

As with Haskell a program is a set of values, wih the "main" value determining 
the program's behaviour.

\subsubsection{Literals}

Literals are the same as haskell \\ \\
\begin{tabular}{ |c|c| } 
\hline
Examples & Type \\ 
\hline
\hline
1, 2, 17, 42, -100 & Int \\ 
\hline
1.61, 2.71, 3.14, -1234.567 & Real \\ 
\hline
'a', 'b', 'c', 'x', 'y', 'z', '.', ',', '\textbackslash n' & Char \\
\hline
[1, 2, 3], ['a', 'b', 'c'], [1.61, 2.71, 3.14 ] & List \\
\hline
\end{tabular}

\subsubsection{Identifiers}

lower case or underscore

\subsubsection{Operators}

\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type & Description \\ 
\hline
\hline
\texttt{==>} & (A, A \ra B) \ra B & Right function application \\
\hline
\texttt{<==} & (A \ra B, A) \ra B & Left function application \\
\hline
\texttt{o>} & (A \ra B, B \ra C) \ra (A \ra C) & Right function composition \\
\hline
\texttt{<o} & (B \ra C, A \ra B) \ra (A \ra C) & Left function composition  \\
\hline
\texttt{\^} & (A)ToThe(B)Gives(C) \Ra (A, B) \ra C & General exponentiation \\
\hline
\texttt{*} & (A)And(B)MultiplyTo(C) \Ra (A, B) \ra C & General multiplication \\
\hline
\texttt{/} & (A)Divides(B)To(C) \Ra (A, B) \ra C & General division \\
\hline
+ & (A)And(B)AddTo(C) \Ra (A, B) \ra C & General addition \\ 
\hline
- & (A)SubtractsFrom(B)To(C) \Ra (B, A) \ra C & General subtraction \\
\hline
= /= & (A)HasEquality \Ra (A, A) \ra Bool & Equality operators \\
\hline
\texttt{> < >= <=} & (A)HasOrder \Ra (A, A) \ra Bool & Order operators \\
\hline
\texttt{\& |} & (Bool, Bool) \ra Bool & Boolean operators \\
\hline
\texttt{>>=} & (M)IsAMonad \Ra (M(A), A \ra M(B)) \ra M(B) & Monad application 
(right bind) \\
\hline
\texttt{=<<} & (M)IsAMonad \Ra (A \ra M(B), M(A)) \ra M(B) & Monad application 
(left bind) \\
\hline
\end{tabular}

\subsubsection{Functions}

\paragraph{Abstractions}

\begin{verbatim}
x -> body
(x, y, z) -> body
cases -> body
(x, cases, z) -> body
\end{verbatim}

\subsubsection{Value Definitions}

\paragraph{Examples}

\begin{verbatim}
foo: Int
  = 42

val1, val2, val3: Int, Bool, Char
  = 42, true, 'a'

int1, int2, int3: all Int
  = 1, 2, 3

succ: Int -> Int
  = x -> x + 1

f: (Int, Int, Int) -> Int
  = (a, b, c) -> a + b * c
\end{verbatim}

\paragraph{Description}\mbox{} \\\\
To define a new value you give it a name, a type and an expression. It is possible
to group value definitions by seperating the names, the types and the expressions
with commas. It is also possible to use the keyword "all" to give the same type
to all the values.

\subparagraph{Examples in \H}

\begin{verbatim}
foo :: Int
foo = 42

val1 :: Int
val1 = 42
val2 :: Bool
val2 = true
val3 :: Char
val3 = 'a'

int1 :: Int
int1 = 1
int2 :: Int
int2 = 2
int3 :: Int
int3 = 3

succ :: Int -> Int
succ = \x -> x + 1

f :: Int -> Int -> Int -> Int
f = \a b c -> a + b * c
\end{verbatim}

\subsection{Types}

\subsubsection{Type annotations}

\paragraph{Differences with Haskell}

\subsubsection{Type definitions}

\paragraph{Or Types}

\subparagraph{Examples}

\begin{verbatim}
or_type Bool
values true | false

or_type Possibly<==A
values indeed<==(value: A) | nothing

or_type ListOf(A)s
values non_empty<==(value: NonEmptyListOf(A)s) | empty

tuple_type NonEmptyListOf(A)s
value (head: T, tail: ListOf(A)s)

is_empty: ListOf(A)s -> Bool
  = cases -> 
    empty -> true
    non_empty -> false

get_head: ListOf(A)s -> Possibly<==A
  = cases -> 
    empty -> nothing
    non_empty -> head==>indeed
\end{verbatim}

\subparagraph{Description}\mbox{} \\\\
Values of an Or Type are one of many cases that possibly have values of other types
inside. Or Types together with Int and Char are the only types on which the "cases"
syntax can be used.

\subparagraph{Examples in \H}

\begin{verbatim}
{-# language LambdaCase #-}

data Bool =
  Ctrue | Cfalse

data Possibly a =
  Cwrapper a | Cnothing

data ListOf_s a =
  Cnon_empty (NonEmptyListOf_s a) | Cempty

data NonEmptyListOf_s a =
  CNonEmptyListOf_s a (ListOf_s a)

is_empty :: ListOf_s a -> Bool
is_empty = \case
  Cempty -> Ctrue
  Cnon_empty (CNonEmptyListOf_s head tail) -> Cfalse

get_head :: ListOf_s a -> Possibly a
get_head = \case
  Cempty -> Cnothing
  Cnon_empty (CNonEmptyListOf_s head tail) -> Cwrapper head
\end{verbatim}

\paragraph{Autogenerated Functions}\mbox{} \\\\
Or Types the following have automatically generated functions:

\begin{verbatim}
is_case:
\end{verbatim}

\paragraph{Tuple Types}

\subparagraph{Examples}

\begin{verbatim}
tuple_type ClientInfo
value (name: String, age: Int, nationality: String)

tuple_type ExprT==>WithPosition
value (expr: ExprT, line: Int, column: Int)

tuple_type (FirstT, SecondT)==>Pair
value (first: FirstT, second: SecondT)
\end{verbatim}

\subparagraph{Description}\mbox{} \\\\
Tuple types group many values into a single value.

\subparagraph{Examples in \H}

\begin{verbatim}
data ClientInfo =
  ClientInfoC String Int String

data WithPosition a = 
  WithPositionC a Int Int

data Pair a b = 
  PairC a b
\end{verbatim}

\subparagraph{Autogenerated Functions}\mbox{} \\\\

\subsection{Type Logic}

\paragraph{Type Predicate}

\paragraph{Type Theorem}

\subsection{Grammar}
\subsubsection{Tokens}

\paragraph{Keywords}

\begin{verbatim}
cases use_fields tuple_type or_type
\end{verbatim}

\paragraph{Value names}

\begin{grammar}
<value-name> ::= 
<lower-case-letter> ( <lower-case-letter> | `_' )*
\end{grammar}

\paragraph{Type names}

\begin{grammar}
<type-name> ::= 
<upper-case-letter> ( <upper-case-letter> | <lower-case-letter> )*
\end{grammar}



\subsubsection{Core Grammar}

\setlength{\grammarparsep}{20pt}
\setlength{\grammarindent}{12em}

\paragraph{Program}
\hspace{1cm}\\
\begin{grammar}

<program> ::= (<value-defs> | <type-def>)+

<value-defs> ::=
<value-names> `:\ ' (<types> | `all' <type>) `\\n\ \ =' <value-exprs>

<value-names> ::= <value-name> ( `,\ ' <value-name> )*  

<types> ::= <type> ( `,\ ' <type> )*  

<value-exprs> ::= <value-expr> ( `,\ ' <value-expr> )*  

\end{grammar}
\hspace{1cm}\\

\paragraph{Types}

\hspace{1cm}\\
\begin{grammar}

<type> ::= <func-type> | <prod-type> | <type-app>

<func-type> ::= <input-types-expr> `\ ->\ ' <output-type>

<prod-type> ::= <prod-sub-type> ( `\ x\ ' <prod-sub-type> )+

<type-app> ::= [ <t-inputs> `==>' ] <type-name> [ `<==' <t-inputs> ]
 
<input-types-expr> ::= <many-ts-in-paren> | <one-type>

<output-type> ::= <prod-type> | <type-app>

<prod-sub-type> ::= `(' ( <func-type> | <prod-type> ) `)' | <type-app>

<one-type> ::= `(' <func-type> `)' | <prod-type> | <type-app>

<t-inputs> ::= <many-ts-in-paren> | `(' <type> `)' | <type-name>

<many-ts-in-paren> ::=  `(' <type> (`, ' <type>)+ `)'

\end{grammar}


\hspace{1cm}\\

\paragraph{Value Expressions}

\hspace{1cm}\\
\begin{grammar}

<value-expr> ::= [ <input-expr> ] <cases-or-where> | <op-expr>

<cases-or-where> ::= <cases-expr> | <where-expr>

<where-expr> ::=
`let' <spicy-nl> (<value-defs> <spicy-nls>)+ `in' <value-expr> <spicy-nl>

<cases-expr> ::= `cases' ( <case> )+ [ <default-case> ]

\end{grammar}

\section{Parser implimentation}

The parser was implemented using the parsec library.

\subsection{AST Types}

\subsection{Parsers}

\section{Translation to \H}
\section{Running examples}
\section{Conclusion}

\section{To be removed or incorporated}

Addition/Subtraction:
\begin{verbatim}
+ : (A)HasAddition => (A, A) -> A
- : (A)HasSubtraction => (A, A) -> A
\end{verbatim}
Equality and ordering:
\begin{verbatim}
= : (A)HasEquality => (A, A) -> Bool
<= : (A)HasOrder => (A, A) -> Bool
>= : (A)HasOrder => (A, A) -> Bool
\end{verbatim}

(fmap)\texttt{<inside>} | (W)IsAWrapper \Ra (A \ra B, W(A)) \ra W(B) | Apply inside operator \\
\texttt{(<*>)<wrapped_inside>} | (W)IsAWrapper \Ra (W(A \ra B), W(A)) \ra W(B) | Order operators \\

better as postfix functions \\
\hspace{1cm}\\
%\newpage

%EDE
%\paragraph{Examples}
%
%\begin{verbatim}
%\end{verbatim}
%
%\paragraph{Description}\mbox{} \\\\
%desc
%
%\paragraph{Examples in \H}
%
%\begin{verbatim}
%\end{verbatim}

%  \includegraphics[width=10cm, height=8cm]{../Images/image.png}

\end{document}
