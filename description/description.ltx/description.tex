\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{syntax}
\usepackage{array}
\usepackage[left=2cm,right=2cm,top=2cm]{geometry}

\date{}
\author{
  Dimitris Saridakis
}

\def\imgs{../Images}
\def\H{Haskell}
\def\ra{\texttt{=>}\ }
\def\Ra{\texttt{-->}\ }
\def\pend{\mbox{} \\\\}
%\newcommand\_[_]{_}

\renewcommand{\arraystretch}{1.5}

\begin{document}

\title{
\textbf{Lambda Cases (lcases)}
}
\maketitle

%\setcounter{tocdepth}{4}
%\setcounter{secnumdepth}{4}
\tableofcontents

\section{Introduction}

\H\ is a delightful language. Yet, for some reason, it doesn't seem to have it's 
rightful place in terms of popularity in industry. Why is it so?
Is it inherently hard to learn
and therefore only the brave enough students and corporations dare to use it, or
could it be that the syntax is perplexing to the amateur eye? It is my belief that 
with some syntax changes that give a greater familiarity to the new user, there
would be no language more compelling than (the new) \H. In an attempt to achieve
that familiarity, I present some new syntax, of which
some is closer to the imperative/OOP style (to attract more already experienced
programmers from these languages), some is closer to mathematics (in which most 
programmers should be experienced) and some is closer to natural language
(in which we are all already experienced). 

\section{Language Description}

An lcases program consists of a set of value, type and predicate definitions along
with type theorems. The "main" value determines the program's behaviour.
Constants and functions are all considered values and they have no real distinction
other than the fact that functions have a function type and constants don't.
Functions (just like "values") can be passed to other functions as arguments or can
be returned as a result of other functions. 

\paragraph{Program example: extended euclidean alogirthm}
\begin{verbatim}
// type definitions

tuple_type Coeffs
value (previous, current) : Int x Int

tuple_type GcdAndCoeffs
value (gcd, a, b) : Int x Int x Int

// algorithm

extended_euclidean: (Int, Int) => GcdAndCoeffs
  = (init_a_coeffs, init_b_coeffs) -> ee_recursion

init_a_coeffs, init_b_coeffs: all Coeffs
  = (1, 0), (0, 1)

ee_recursion: (Coeffs, Coeffs, Int, Int) => GcdAndCoeffs
  = (a_coeffs, b_coeffs, x, cases) =>
    0 => (x, a_coeffs.previous, b_coeffs.previous)
    y =>
      ee_recursion(next <- a_coeffs, next <- b_coeffs, y, x -> mod <- y)
      where
      next: Coeffs => Coeffs
        = fields => (current, previous - x / y * current)

// reading, printing and main

read_two_ints : (Int x Int)WithIO
  = print <- "Please give me 2 ints";
    get_line :> split_words o> apply(from_string)to_all o> ints =>
    ints -> length -> cases =>
      2 => ints -> with_io
      ... => io_error <- "You didn't give me 2 ints"
 
print_gcd_and_coeffs : GcdAndCoeffs => (EmptyValue)WithIO
  = fields => print("Gcd: " + gcd + "\nCoefficients: a = " + a + ", b = " + b)

main : (EmptyValue)WithIO
  = read_two_ints :> ints =>
    extended_euclidean(ints.1st, ints.2nd) -> print_gcd_and_coeffs
\end{verbatim}

\subsection{Basic Expressions}

\subsubsection{Literals and Identifiers}

\paragraph{Literals}
\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
1  2  17  42  -100
1.61  2.71  3.14  -1234.567
'a'  'b'  'c'  'x'  'y'  'z'  '.'  ','  '\n'
"Hello World!"  "What's up, doc?"  "Alrighty then!"
\end{verbatim}

\item \textit{Description} \\\\
We have literals for the four basic types: Int, Real, Char, String. These are the 
usual integers, real numbes, characters and strings. The exact specification of 
literals is the same as in the \H\ report.

\item \textit{Grammar}
\begin{grammar}
<literal> ::= <literal>
\end{grammar}
TODO add the grammar from the haskell report

\end{itemize}


\paragraph{Identifiers}
\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
x y z
a1 a2 a3 
funny_identifier 
unnecessarily_long_identifier
apply()to_all
\end{verbatim}

\item \textit{Description} \\\\
An identifier is a string used as the name of a value. It is first used in the
definition of the value (see "value definition" section \ref{subsec:valdefs})
and later used in the definition of other values that use that defined value.
An identifier starts with a lower case letter and is followed by lower case
letters or underscores. It also possible to have a pairs of parentheses in the
middle of an identifier (see "parenthesis function application" section
\ref{subsec:parenfuncapp}). Finally, an identifier can be ended with a digit.

\item \textit{Grammar}
\begin{grammar}
<identifier> ::= [a-z]( [a-z_] | `()'[a-z_] )* [ [0-9] ]
\end{grammar}

\end{itemize}

\newpage
\subsubsection{Tuples and Lists}

\paragraph{Tuples}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
(1, "What's up, doc?")
(2, "Alrighty then!", 3.14)
(x, y, z, w)
(1, my_function, (x, y, z) => (x ^ 2 + y ^ 2 + z ^ 2) ^ (1/2))
\end{verbatim}

\item \textit{Description} \\\\
Tuples are used to group many values (of possibly different types) into one.
The type of the tuple can be either the product of the types of the subvalues or a
defined tuple\_type which is equivalent to the afformentioned product type i.e.
the product type is in the definition of the tuple\_type (see "tuple\_type"
section \ref{subsec:tupts}). For example, the type of the second example above 
could be:
\begin{verbatim}
Int x String x Real
\end{verbatim}
or:
\begin{verbatim}
MyType
\end{verbatim}
assuming "MyType" has been defined in a similar way to the following:
\begin{verbatim}
tuple_type MyType
value (my_int, my_string, my_real) : Int x String x Real
\end{verbatim}

\item \textit{Grammar}
\begin{grammar}
<tuple> ::= `(' <value-expression> ( `,\ ' <value-expression> )+ `)'
\end{grammar}

\end{itemize}

\paragraph{Lists}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
[1, 2, 17, 42, -100]
[1.61, 2.71, 3.14, -1234.567]
["Hello World!", "What's up, doc?", "Alrighty then!"]
[x, y, z, w]
\end{verbatim}

\item \textit{Description} \\\\
Lists are used to group many values of the same type into one. 
The type of the list is ListOf(A)s where A is the type of every value inside.
Therefore, the types of the first three examples are:
\begin{verbatim}
ListOf(Int)s
ListOf(Real)s
ListOf(String)s
\end{verbatim}
And the last list is only legal if x, y, z and w all have the same type. Assuming 
they do and it's the type T, the type of the list is: 
\begin{verbatim}
ListOf(T)s
\end{verbatim}

\item \textit{Grammar}
\begin{grammar}
<list> ::= `[' [<value-expression> ( `,\ ' <value-expression> )*] `]'
\end{grammar}

\end{itemize}

\subsection{Operators}

\subsubsection{Function Application Operators}

The function application operators "\texttt{->}" and "\texttt{<-}" are a different
way to apply functions to arguments than the usual parenthesis function application.
Each one applies the function from the corresponding direction. The operators are 
meant to look like arrows that point from the argument to the function.
These operators are very useful for chaining many function applications without the
clutter of having to open and close parentheses for each one of the functions.\\\\
For example, assuming we have the following functions with the behaviour suggested
by their names and types:
\begin{verbatim}
apply()to_all : (A => B, ListOf(A)s) => ListOf(B)s
string_length: String => Int
filter : (A => Bool, ListOf(A)s) => ListOf(A)s
is_odd : Int => Bool
sum_ints : ListOf(Int)s => Int
\end{verbatim}
And a list of strings:
\begin{verbatim}
strings : ListOf(String)s
\end{verbatim}
Here is a simple way to get the number of characters in all the strings that have 
odd length:
\begin{verbatim}
chars_in_odd_length_strings : Int
  = strings -> apply(string_length)to_all -> filter(is_odd) -> sum_ints
\end{verbatim}
Ofcourse this can be done equivalently using the other operator:
\begin{verbatim}
chars_in_odd_length_strings : Int
  = sum_ints <- filter(is_odd) <- apply(string_length)to_all <- strings
\end{verbatim}
These operators can also be used together to put a function between two arguments
if that function is commonly used that way in math (or if it looks better for a
certain function). For example the "mod" function can be used like so:
\begin{verbatim}
x -> mod <- y
\end{verbatim}
Instead of:
\begin{verbatim}
mod(x, y)
\end{verbatim}
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{->} & (A, A \ra B) \ra B \\
\hline
\texttt{<-} & (A \ra B, A) \ra B \\
\hline
\end{tabular}
\end{center}


\subsubsection{Function Composition Operators}
The function composition operators "\texttt{o>}" and "\texttt{<o}" are used to 
compose funtions, each one in the corresponding direction. The use of the letter 'o'
is meant to be similar to the mathematical function composition symbol '\(\circ\)'
and the symbols '\texttt{>}', '\texttt{<}' are used so that the operator points from
the function which is applied first to the function which is applied second.
A neat example using function composition is the following. Assuming we have the
following functions with the behaviour suggested by their names and types: 
\begin{verbatim}
split_words : String => ListOf(String)s
apply()to_all : (A => B, ListOf(A)s) => ListOf(B)s
reverse_word: String => String
merge_words : ListOf(String)s => String
\end{verbatim}
We can reverse the all the words in a string like so:
\begin{verbatim}
reverse_words : String => String
  = split_words o> apply(reverse_word)to_all o> merge_words
\end{verbatim}
Ofcourse this can be done equivalently using the other operator:
\begin{verbatim}
reverse_words : String => String
  = merge_words <o apply(reverse_word)to_all <o split_words
\end{verbatim}

\subsubsection{Arithmetic Operators}

The usual arithmetic operators work as they are expected, similarly to mathematics
and other programming languages. However, they are generalized. The examples below 
show their generality:
\begin{verbatim}
>> 1 + 1
2
>> 1 + 3.14
4.14
>> 'a' + 'b'
"ab"
>> 'w' + "ord"
"word"
>> "Hello " + "World!"
"Hello World!"
>> 5 * 'a'
"aaaaa"
>> 5 * "hi"
"hihihihihi"
>> "1,2,3" - ','
"123"
\end{verbatim}
The generality can also be seen from their types in the table below:
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{\^} & (A)ToThe(B)Gives(C) \Ra (A, B) \ra C \\
\hline
\texttt{*} & (A)And(B)MultiplyTo(C) \Ra (A, B) \ra C \\
\hline
\texttt{/} & (A)Divides(B)To(C) \Ra (B, A) \ra C \\
\hline
+ & (A)And(B)AddTo(C) \Ra (A, B) \ra C \\ 
\hline
- & (A)SubtractsFrom(B)To(C) \Ra (B, A) \ra C \\
\hline
\end{tabular}
\end{center}
Let's analyze further the example of addition. The type can be read as such:
the '+' operator has the type \\ (A, B) \ra C, provided that the type
proposition (A)And(B)AddTo(C) holds. This proposition being true, means that
addition has been defined for these three types (see section "type logic"
\ref{subsec:typelogic} for more on type propositions). For example, by the examples
above we can see that the following propositions are true (in the order of the 
examples):
\begin{verbatim}
(Int)And(Int)AddTo(Int)
(Int)And(Real)AddTo(Real)
(Char)And(Char)AddTo(String)
(Char)And(String)AddTo(String)
(Int)And(Char)MultiplyTo(String)
(Int)And(String)MultiplyTo(String)
(Char)SubtractsFrom(String)To(String)
\end{verbatim}
This allows us to use the familiar arithmetic operators in types that are not
necessarily numbers but it is somewhat intuitively obvious what the should do
in those other types. Furthermore, their behaviour can be defined by the user
for new user defined types!

\subsubsection{Comparison and Boolean Operators}

\subsubsection{Monadic Operators}

\subsubsection{Complete Table, Precedence, Associativity and Grammar}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type & Description \\ 
\hline
\hline
\texttt{->} & (A, A \ra B) \ra B & Right function application \\
\hline
\texttt{<-} & (A \ra B, A) \ra B & Left function application \\
\hline
\texttt{o>} & (A \ra B, B \ra C) \ra (A \ra C) & Right function composition \\
\hline
\texttt{<o} & (B \ra C, A \ra B) \ra (A \ra C) & Left function composition \\
\hline
\texttt{\^} & (A)ToThe(B)Gives(C) \Ra (A, B) \ra C & General exponentiation  \\
\hline
\texttt{*} & (A)And(B)MultiplyTo(C) \Ra (A, B) \ra C & General multiplication  \\
\hline
\texttt{/} & (A)Divides(B)To(C) \Ra (B, A) \ra C & General division \\
\hline
+ & (A)And(B)AddTo(C) \Ra (A, B) \ra C & General addition \\ 
\hline
- & (A)SubtractsFrom(B)To(C) \Ra (B, A) \ra C & General subtraction \\
\hline
= /= & (A)HasEquality \Ra (A, A) \ra Bool & Equality operators \\
\hline
\texttt{> < >= <=} & (A)HasOrder \Ra (A, A) \ra Bool & Order operators \\
\hline
\texttt{\& |} & (Bool, Bool) \ra Bool & Boolean operators \\
\hline
\texttt{:>} & (E)IsAnEnvironment \Ra (E(A), A \ra E(B)) \ra E(B) &
Monad bind \\
\hline
\texttt{;} & (E)IsAnEnvironment \Ra (E(A), E(B)) \ra E(B) &
Monad then \\
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Precedence & Associativity \\ 
\hline
\hline
\texttt{->} & 10 & Left \\
\hline
\texttt{<-} & 9 & Right \\
\hline
\texttt{o> <o} & 8 & Left \\
\hline
\texttt{\^} & 7 & Right \\
\hline
\texttt{* /} & 6 & Left \\
\hline
\texttt{+ -} & 5 & Left \\ 
\hline
\texttt{= /= > < >= <=} & 4 & None \\
\hline
\texttt{\&} & 3 & Left \\
\hline
\texttt{|} & 2 & Left \\
\hline
\texttt{:> ;} & 1 & Left \\
\hline
\end{tabular}
\end{center}

\paragraph{Grammar}
\begin{grammar}
<operator-expression> ::= <operator-argument> <operator> <right-operator-argument>

<operator-argument> ::=
<literal> | <identifier> | <parentheses-function-application> |
<parentheses-expression>

<right-operator-argument> ::= <operator-argument> | <function-expression>

<operator> ::= `\ ' <op> `\ '

<op> ::= 
`->' | `<-' | `o>' | `<o' | `^' | `*' | `/' | `+' | `-' |
`=' | `/=' | `>' | `<' | `>=' | `<=' | `\&' | `|' | `:>' | `;'
\end{grammar}

\subsection{Functions}
\subsubsection{Parenthesis Function Application}
\label{subsec:parenfuncapp}

\paragraph{Examples}

\begin{verbatim}
f(x)
f(x, y, z)
(x)to_string
apply(f)to_all
apply(f)to_all(l)
\end{verbatim}

\paragraph{Description}\pend
Function application in lcases can be done in many different ways in an attempt to 
maximize readability. In this section, we discuss the ways function application can
be done with parenthesis. In the first two examples, we have the usual mathematical
function application which is also used in most programming languages and
should be familiar to the reader. That is, function application is done with the 
arguments of the function in parenthesis seperated by commas and \textbf{appended}
to the function identifier.
\\\\
We extend this idea by allowing the arguments to be \textbf{prepended} to the
function identifier (third example). Finally, it is also possible to to have
the arguments \textbf{inside} the function identifier provided the function has
been \textbf{defined with parentheses inside the identifier}. For example,
below is the definition of "apply()to\_all":

\begin{verbatim}
apply()to_all: (A => B, ListOf(A)s) => ListOf(B)s
  = (f, cases) =>
    empty => empty
    non_empty:l => non_empty:(f <- l.head, apply(f)to_all <- l.tail)
\end{verbatim}
The actual definition doesn't matter at this point, what matters is that the 
identifier is "apply()to\_all" with the parentheses \textbf{included}. This is very
useful for defining functions where the argument in the middle makes the function
application look and sound more like natural language.
\\\\
In is possible that many paratheses pairs are present in a single function
application (last example). The arguments are always inserted to the function
from \textbf{left to right}.  Therefore, when multiple parentheses pairs are
present the arguments of the leftmost parentheses are inserted first then the
next ones to the right and so on.

\paragraph{Grammar}
\begin{grammar}
<parenthesis-function-application> ::= ""\\
<arguments> ( <identifier-with-arguments> | <identifier> )
\alt ( <identifier-with-arguments> | <identifier> ) <arguments>
\alt <identifier-with-arguments>

<arguments> ::= `(' <value-expression> ( `,\ ' <value-expression> )* `)'

<identifier-with-arguments> ::= ""\\""
[a-z] <id-char-or-paren-id-char>* ( <arguments> [a-z_]
<id-char-or-paren-id-char>* )+ [ [0-9] ]

<id-char-or-paren-id-char> ::= [a-z_] | `()'[a-z_]
\end{grammar}

\subsubsection{Function Expressions}

\paragraph{Examples}

\begin{verbatim}
a => 17 * a + 42

(x, y, z) => (x ^ 2 + y ^ 2 + z ^ 2) ^ (1 / 2)
\end{verbatim}

\paragraph{Description}\pend
Function expressions are used to define functions or pass anonymous functions as 
arguments to other functions. They are comprised by their parameters and their 
body. The parameters are either only one in which case a single identifier is used, 
or they are many in which case many identifiers are used in parentheses, seperated 
by a comma. The parameters and the body are seperated by an arrow.
The body is an operator expression.

\paragraph{Grammar}
\begin{grammar}
<function-expression> ::= <parameters> `\ =>\ ' <operator-expression>

<parameters> ::= <identifier> | `(' <identifier> ( `,\ ' <identifier> )+ `)'
\end{grammar}

\subsubsection{Special Function Parameters}

\begin{verbatim}
x => body
(x, y, z) => body
cases => body
(x, cases, z) => body
\end{verbatim}

\subsubsection{Expressions}

\paragraph{Examples}

\begin{verbatim}
42

x

funny_identifier 

[1, 2, 3]

"Hello world!"

x -> mod <- y

1.61 * 2.71 + 3.14

a => 17 * a + 42

(x, y, z) => (x ^ 2 + y ^ 2 + z ^ 2) ^ (1 / 2)

n -> +1 -> ^2 -> *3 -> print

f(x, y, z) + g(1, 2, 3)
\end{verbatim}

\paragraph{Description}\pend
The base of expressions, are literals and identifiers, those can be combined either
with operators, or by normal function application with mathematical notation. 
Finally, on top of that there can be added one of more abstractions (parameters)
in the beginning of the expressions with an arrow.

\paragraph{Grammar}\pend

\subsection{Value Definitions}
\label{subsec:valdefs}

\paragraph{Examples}

\begin{verbatim}
foo : Int
  = 42

val1, val2, val3 : Int, Bool, Char
  = 42, true, 'a'

int1, int2, int3 : all Int
  = 1, 2, 3

succ : Int => Int
  = +1

f : (Int, Int, Int) => Int
  = (a, b, c) => a + b * c
\end{verbatim}

\paragraph{Description}\pend
To define a new value you give it a name, a type and an expression. It is possible
to group value definitions by seperating the names, the types and the expressions
with commas. It is also possible to use the keyword "all" to give the same type
to all the values.

\paragraph{Grammar}
\begin{grammar}
<value-definitions> ::=
<identifiers> `\ :\ ' (<types> | `all' <type>) `\\n\ \ =' <value-expressions>

<identifiers> ::= <identifier> ( `,\ ' <identifier> )*  

<types> ::= <type> ( `,\ ' <type> )*  

<value-expressions> ::= <value-expression> ( `,\ ' <value-expression> )*  
\end{grammar}


\subsection{Types}

\subsubsection{Type expressions}

\paragraph{Examples}

\begin{verbatim}
Int

String => String 

Int x Int 

Int x Int => Real

A => A

(A => B, B => C) => (A => C)

((A, A) => A, A, ListOf(A)s) => A

((B, A) => B, B, ListOf(A)s) => B

(T)HasStringRepresantion --> T => String
\end{verbatim}

\paragraph{Description}\pend
\begin{tabular}{ |c|c| } 
\hline
Examples & Description \\ 
\hline
\hline
Int & \\
Char & Base types \\
String & \\ 
\hline
A \ra A &
Polymorphic types. A, B, C ... are type variables
\\
(A \ra B, B \ra C) \ra (A \ra C) &
\\ 
\hline
\end{tabular}

\paragraph{Differences from Haskell}\pend
\begin{tabular}{ |c|c|c| } 
\hline
lcases & haskell & difference description \\ 
\hline
\hline
A \ra A & a \ra a & Type variables for polymorphic types are  \\ 
\hline
\end{tabular}

\paragraph{Grammar}
\begin{grammar}
<type> ::= <type-application> | <product-type> | <function-type> \\

<type-application> ::=
[ <types-in-paren> ] <type-identifier> (<types-in-paren> ( [A-Za-z] )*)* [ <types-in-paren> ] 

<types-in-paren> ::= `(' <type> (`, ' <type>)* `)'

<type-identifier> ::= [A-Z] ( [A-Za-z] )* \\ 
 
<product-type> ::= <product-subtype> ( `\ x\ ' <product-subtype> )+

<product-subtype> ::=
`(' ( <function-type> | <product-type> ) `)' | <type-application> \\

<function-type> ::= <input-types-expression> `\ =>\ ' <one-type>

<input-types-expression> ::= <one-type> | <two-or-more-types-in-paren>

<one-type> ::= <type-application> | <product-type> | `(' <function-type> `)'

<two-or-more-types-in-paren> ::=  `(' <type> (`, ' <type>)+ `)'
\end{grammar}

\subsubsection{Tuple Types}
\label{subsec:tupts}

\paragraph{Definition Examples}

\begin{verbatim}
tuple_type Name
value (first_name, last_name) : String x String

tuple_type ClientInfo
value (name, age, nationality) : Name x Int x String

tuple_type Date
value (day, month, year) : Int x Int x Int

tuple_type (A)And(B)
value (a_value, b_value) : A x B

tuple_type (ExprT)WithPosition
value (expr, line, column) : ExprT x Int x Int
\end{verbatim}

\paragraph{Usage Examples}

\begin{verbatim}
giorgos_info : ClientInfo
  = (("Giorgos", "Papadopoulos"), 42, "Greek")

john_info : ClientInfo
  = (("John", "Doe"), 42, "American")

name_to_string : Name => String
  = fields => "First Name: " + first_name + "\nLast Name: " + last_name

print_name_and_nationality : ClientInfo => (EmptyValue)WithIO
  = fields => print(name -> name_to_string + "\nNationality: " + nationality)

print_error_in_expr : (SomeDefinedExprT)WithPosition => (EmptyValue)WithIO
  = ewp =>
    print(
      "Error in the expression:" + es +
      "\nAt the position: (" + ls + ", " + cs + ")"
    )
    where
    es, ls, cs : all String
      = ewp.expr->to_string, ewp.line->to_string, ewp.column->to_string
\end{verbatim}

\paragraph{Description}\pend
Tuple types group many values into a single value. They are specified by their name,
the names of their subvalues and the types of their subvalues. They generate 
projection functions for all of their subvalues by using a '.' before the name of 
the subvalue. For example the ClientInfo type above generates the following 
functions:
\begin{verbatim}
.name : ClientInfo => String
.age : ClientInfo => Int
.nationality : ClientInfo => String
\end{verbatim}
These functions shall be named "postfix functions" as the can just be appended to
their argument.

\paragraph{Definition Grammar}
\begin{grammar}
<tuple-type-definition> ::= ""\\
`tuple_type\ ' <type-application>
`\\nvalue\ ' `(' <identifier> (`,\ ' <identifier>)* `)' `\ :\ ' <product-type>
\end{grammar}

\subsubsection{Or Types}

\paragraph{Examples}

\begin{verbatim}
or_type Bool
values true | false

or_type Possibly(A)
values the_value:A | no_value

or_type ListOf(A)s
values non_empty:HeadAndTailOf(A)s | empty

tuple_type HeadAndTailOf(A)s
value (head : A, tail : ListOf(A)s)

is_empty : ListOf(A)s => Bool
  = cases => 
    empty => true
    non_empty:anything => false

get_head : ListOf(A)s => Possibly(A)
  = cases => 
    empty => no_value
    non_empty:list => the_value:list.head
\end{verbatim}

\paragraph{Description}\pend
Values of an or\_type are one of many cases that possibly have other values inside.
The cases which have other values inside are followed by a semicolon and the 
type of the internal value. The same syntax can be used for matching that particular 
case in a fucntion using the "cases" syntax, with the difference that after the
colon, we write the name given to the value inside. 
Or\_types and basic types are the only types on which
the "cases" syntax can be used. The cases of an or\_type which have a value
inside create functions. For example, the case "non\_empty" of a list creates the
function "non\_empty:" for which we can say:
\begin{verbatim}
non_empty: : HeadAndTailOf(A)s => ListOf(A)s
\end{verbatim}
Similarly:
\begin{verbatim}
the_value: : A => Possibly(A)
\end{verbatim}
These functions shall be named "prefix functions" as they are prepended to their
argument.
For example:
\begin{verbatim}
head_and_tail : HeadAndTailOf(Int)s
  = (1, [2, 3, 4])

list : ListOf(Int)s
  = non_empty:head_and_tail
\end{verbatim}
These functions can be used like any other function as arguments to other functions.
For example:
\begin{verbatim}
heads_and_tails_to_lists : ListOf(HeadAndTailOf(A)s)s => ListOf(ListOf(A)s)s
  = apply(non_empty:)to_each
\end{verbatim}

\paragraph{Definition Grammar}
\begin{grammar}
<or-type-definition> ::= ""\\
`or_type\ ' <type-application> 
`\\nvalues\ ' <identifier> [ `:' <type> ] ( `\ |\ ' <identifier> [ `:' <type> ])*
\end{grammar}

\subsection{Type Logic}
\label{subsec:typelogic}

\subsubsection{Type Predicate}

\subsubsection{Type Proposition}

\subsubsection{Type Theorem}

\subsection{Grammar}
\subsubsection{Tokens}

\paragraph{Keywords}

\begin{verbatim}
cases use_fields tuple_type or_type
\end{verbatim}

\paragraph{Value names}

\paragraph{Type names}

\subsubsection{Core Grammar}

\setlength{\grammarparsep}{20pt}
\setlength{\grammarindent}{12em}

\paragraph{Program}
\hspace{1cm}\\
\begin{grammar}

<program> ::= (<value-definitions> | <type-def>)+

<value-definitions> ::=
<identifiers> `\ :\ ' (<types> | `all' <type>) `\\n\ \ =' <value-expressions>

<identifiers> ::= <identifier> ( `,\ ' <identifier> )*  

<types> ::= <type> ( `,\ ' <type> )*  

<value-expressions> ::= <value-expression> ( `,\ ' <value-expression> )*  

\end{grammar}
\hspace{1cm}\\

\paragraph{Types}

\hspace{1cm}\\


\hspace{1cm}\\

\paragraph{Value Expressions}

\hspace{1cm}\\
\begin{grammar}

<value-expression> ::= [ <input-expr> ] <cases-or-where> | <op-expr>

<cases-or-where> ::= <cases-expr> | <where-expr>

<where-expr> ::=
`let' <spicy-nl> (<value-definitions> <spicy-nls>)+ `in' <value-expression> <spicy-nl>

<cases-expr> ::= `cases' ( <case> )+ [ <default-case> ]

\end{grammar}

\section{Notable differences from \H}

\section{Parser implimentation}

The parser was implemented using the parsec library.

\subsection{AST Types}

\subsection{Parsers}

\section{Translation to \H}
\section{Running examples}
\section{Conclusion}

\section{To be removed or incorporated}

Addition/Subtraction:
\begin{verbatim}
+ : (A)HasAddition => (A, A) => A
- : (A)HasSubtraction => (A, A) => A
\end{verbatim}
Equality and ordering:
\begin{verbatim}
= : (A)HasEquality => (A, A) => Bool
<= : (A)HasOrder => (A, A) => Bool
>= : (A)HasOrder => (A, A) => Bool
\end{verbatim}

(fmap)\texttt{<inside>} | (W)IsAWrapper \Ra (A \ra B, W(A)) \ra W(B) | Apply inside operator \\
\texttt{(<*>)<wrapped_inside>} | (W)IsAWrapper \Ra (W(A \ra B), W(A)) \ra W(B) | Order operators \\

better as postfix functions \\
\hspace{1cm}\\
\paragraph{Examples in \H}

\begin{verbatim}
data ClientInfo =
  ClientInfoC String Int String

data WithPosition a = 
  WithPositionC a Int Int

data Pair a b = 
  PairC a b
\end{verbatim}

\paragraph{Examples in \H}

\begin{verbatim}
{-# language LambdaCase #-}

data Bool =
  Ctrue | Cfalse

data Possibly a =
  Cwrapper a | Cnothing

data ListOf_s a =
  Cnon_empty (NonEmptyValueListOf_s a) | Cempty

data NonEmptyValueListOf_s a =
  CNonEmptyValueListOf_s a (ListOf_s a)

is_empty :: ListOf_s a => Bool
is_empty = \case
  Cempty => Ctrue
  Cnon_empty (CNonEmptyValueListOf_s head tail) => Cfalse

get_head :: ListOf_s a => Possibly a
get_head = \case
  Cempty => Cnothing
  Cnon_empty (CNonEmptyValueListOf_s head tail) => Cwrapper head
\end{verbatim}

\paragraph{Examples in \H}
\begin{verbatim}
foo :: Int
foo = 42

val1 :: Int
val1 = 42
val2 :: Bool
val2 = true
val3 :: Char
val3 = 'a'

int1 :: Int
int1 = 1
int2 :: Int
int2 = 2
int3 :: Int
int3 = 3

succ :: Int => Int
succ = \x => x + 1

f :: Int => Int => Int => Int
f = \a b c => a + b * c
\end{verbatim}

Or Types the following have automatically generated functions:

\begin{verbatim}
is_case:
\end{verbatim}
%\newpage

%\paragraph{Examples}
%
%\begin{verbatim}
%\end{verbatim}

%\paragraph{Description}\pend
%desc

%\paragraph{Examples in \H}
%
%\begin{verbatim}
%\end{verbatim}

% \begin{tabular}{ |c|c| } 
% \hline
% 1 & 2 \\ 
% \hline
% \hline
% 1.1 & 1.2 \\ 
% \hline
% \end{tabular}

%  \includegraphics[width=10cm, height=8cm]{../Images/image.png}
\begin{syntdiag}
<ident> ‘(’
\begin{rep} \begin{stack} \\
<type> \begin{stack} \\ <ident> \end{stack}
\end{stack} \\ ‘,’ \end{rep}
\begin{stack} \\ ‘...’ \end{stack} ‘)’
\end{syntdiag}

\paragraph{Hi}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
\end{verbatim}

\item \textit{Description} \\\\
hi

\item \textit{Grammar}
\begin{grammar}
<identifier> ::= [a-z]( [a-z_] | `()'[a-z_] )* [ [0-9] ]
\end{grammar}

\end{itemize}

\end{document}
