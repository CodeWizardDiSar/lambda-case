\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{syntax}
\usepackage{array}
\usepackage{multirow}
\usepackage[left=2cm,right=2cm,top=2cm]{geometry}

\date{}
\author{
  Dimitris Saridakis
}

\def\imgs{../Images}
\def\H{Haskell}
\def\ra{\texttt{=>}\ }
\def\Ra{\texttt{==>}\ }
%\newcommand\_[_]{_}

\renewcommand{\arraystretch}{1.5}

\begin{document}

\title{
\textbf{Lambda Cases (lcases)}
}
\maketitle

%\setcounter{tocdepth}{4}
%\setcounter{secnumdepth}{4}
\tableofcontents

\newpage
\section{Introduction}

\H\ is a delightful language. Yet, for some reason, it doesn't seem to have
its rightful place in terms of popularity in industry. Why is it so?  Is it
inherently hard to learn and therefore only the brave dare to use it, or could
it be that the syntax is perplexing to the amateur eye? It is my belief that
with some syntax changes that give a greater familiarity to the new user, there
would be no language more compelling than (the new) \H. In an attempt to
achieve that familiarity, I present some (hopefully useful) new syntax, of
which some is closer to the imperative/OOP style (to attract more already
experienced programmers from these languages), some is closer to mathematics
(in which most programmers should be experienced) and some is closer to natural
language (in which we are all already experienced). 

\section{Language Description: General}

\subsection{Program Structure}

An lcases program consists of a set of definitions, type nicknames and
theorems.  Definitions are split into value definitions, type definitions and
type proposition definitions. Theorems are proven type propositions. Functions
as well as "Environment Actions" (see section \ref{subsec:envacts}) are also
considered values. The definition of the "main" value determines the program's
behaviour. 

\paragraph{Program example: Euclidean Algorithm}
\begin{verbatim}
gcd : Int^2 => Int
  = (x, cases)
    0 => x
    y => gcd(y, x -> mod <- y) 

read_two_ints : (Int^2)FromIO
  = print <- "Please give me 2 ints";
    get_line ;> split_to_words o> cases
      [x, y] => wrap_with_io(from_string(x), from_string(y))
      ... => show_err("You didn't give me 2 ints")
 
tuple_type NumsAndGcd
value
  (x, y, gcd) : Int^3

print_gcd_message : NumsAndGcd => IO
  = nums_gcd => print(message)
    where
    message : String
      = "The GCD of " + nums_gcd.x + " and " + nums_gcd.y + " is = " + nums_gcd.gcd

main : IO
  = read_two_ints ;> (i1, i2) => print_gcd_message(i1, i2, gcd(i1, i1))
\end{verbatim}

\paragraph{Program grammar}
\begin{grammar}
<program> ::=
<nl>* <program-part> ( <nl> <nl> <program-part> )* <spaces>

<program-part> ::=
<value-def> | <grouped-value-defs> | <type-def> | <t-nickname> | <type-prop-def> |
<type-theo>

<nl> :: ( `\ ' | `\\t' )* `\\n'
\end{grammar}

\subsection{Keywords}

The lcases keywords are the following:
\begin{verbatim}
cases where all tuple_type value or_type values
type_proposition equivalent type_theorem proof
\end{verbatim}
Each keyword's functionality is described in the respective section shown in the 
table below:

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Keyword & Section \\ 
\hline
\hline
\texttt{cases} & \ref{subsec:funcexprs} Function Expressions \\
\hline
\texttt{where all} & \ref{subsec:valdefswhere} Value Definitions \\
\hline
\texttt{tuple_type value or_type values type_nickname} &
\ref{subsec:types} Type Definitions \\
\hline
\texttt{type_proposition value equivalent type_theorem proof} &
{\ref{subsec:typelogic} Type Logic} \\
\hline
\end{tabular}
\end{center}
The "\texttt{cases}" and "\texttt{where}" keywords are also
reserved words. Therefore, even though they can be generated by the
"identifiers" grammar, they cannot be used as identifiers (see "Literals and
Identifiers" section \ref{subsubsec:litsandidents}).

\newpage
\section{Language Description: Values}

\subsection{Basic Expressions}

\subsubsection{Literals and Identifiers}
\label{subsubsec:litsandidents}

\paragraph{Literals}
\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
1  2  17  42  -100
1.61  2.71  3.14  -1234.567
'a'  'b'  'c'  'x'  'y'  'z'  '.'  ','  '\n'
"Hello World!"  "What's up, doc?"  "Alrighty then!"
\end{verbatim}

\item \textit{Description}

There are literals for the four basic types: Int, Real, Char, String. These are the 
usual integers, real numbes, characters and strings.

\item \textit{Grammar}
\begin{grammar}
<literal> ::= <int-lit> | <real-lit> | <char-lit> | <string-lit>
\end{grammar}

\end{itemize}


\paragraph{Identifiers}
\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
x y z
a1 a2 a3 
unnecessarily_long_identifier
self_referencing_identifier 
apply()to_all
\end{verbatim}

\item \textit{Description}

An identifier is the name of a value or a parameter. It is used in the
definition of a value and in expressions that use that value, or in the
parameters of a function and in the body of that function.
\\\\
An identifier starts with a lower case letter and is followed by lower case
letters or underscores. It is also possible to have pairs of parentheses in the
middle of an identifier (see "Parenthesis Function Application" section
\ref{subsec:parenfuncapp} for why this can be useful).  Finally, an identifier
can be ended with a digit.

\item \textit{Grammar}
\begin{grammar}
<identifier> ::= [a-z] [a-z_]* ( `()' [a-z_]+ )* [ [0-9] ]
\end{grammar}
Even though the "\texttt{cases}" and "\texttt{where}" keywords can be generated
by this grammar, they cannot be used as identifiers.

\end{itemize}

\newpage
\subsubsection{Parenthesis, Tuples and Lists}

\paragraph{Parenthesis}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
(1 + 2)
(((1 + 2) * 3)^4)
(val -> (x => f(x) + 1) -> to_string -> (s => "f(val) + 1 is: " + s))
(do(3)times <- (get_line ;> line => print("Line is: " + line)))
\end{verbatim}

\item \textit{Description}

An expression is put in parenthesis to prioritize it or isolate it in a bigger
(operator) expression. The expressions inside parenthesis are operator
or function expressions.
\\\\
Parenethesis expressions cannot extend over multiple lines. For expressions
that extend of over multiple lines new values must be defined.

\item \textit{Grammar}
\begin{grammar}
<paren-expr> ::= `(' <line-op-expr> | <line-func-expr> `)'  
\end{grammar}

\end{itemize}

\paragraph{Tuples}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
(1, "What's up, doc?")
(2, "Alrighty then!", 3.14)
(x, y, z, w)
(1, my_function, (x, y, z) => (x^2 + y^2 + z^2)^(1/2))
\end{verbatim}

\item \textit{Description} 

Tuples are used to group many values (of possibly different types) into one.
The type of a tuple can be either the product of the types of the fields or a
defined \texttt{tuple_type} which is equivalent to the afformentioned product
type (see "Tuple Types" in section \ref{subsubsec:tdefs} for details). For
example, the type of the second tuple above could be:
\begin{verbatim}
Int x String x Real
\end{verbatim}
or:
\begin{verbatim}
MyType
\end{verbatim}
assuming "MyType" has been defined in a similar way to the following:
\begin{verbatim}
tuple_type MyType
value
  (my_int, my_string, my_real) : Int x String x Real
\end{verbatim}

\item \textit{Big Tuples}
\\\\
\textbf{Example}
\begin{verbatim}
my_big_tuple
  : String x Int x Real x String x String x (String x Real x Real)
  = ( "Hey, I'm the first field and I'm also a relatively big string."
    , 42, 3.14, "Hey, I'm the first small string", "Hey, I'm the second small string"
    , ("Hey, I'm a string inside the nested tuple", 2.71, 1.61)
    )
\end{verbatim}

\textbf{Description}

It is possible to stretch a (big) tuple expression over multiple lines (only)
in a seperate value definition (see "Value Definitions" section
\ref{subsubsec:valdefs}).  In that case:
\begin{itemize}
\item
The character '(' is after the "= " part of the value definition
and the first field must be in the same line.

\item
The tuple can split in a new line only at a ',' character. Every such line must
be indented so that the ',' is in same column where the '(' character was in
the first line.

\item
The tuple must be ended by a line that only contains the ')' character and is 
also indented so that the ')' is in same column where the '(' character was in
the first line.

\item
The precise indentation rules are described in the section
"Indentation System" \ref{subsubsec:indsys}.
\end{itemize}

\item \textit{Tuples with empty fields}
\\\\
\textbf{Example}
\begin{verbatim}
(42, )
(, 3.14, )
(, , "Hello from 3rd field")
\end{verbatim}

\textbf{Description}\\\\
It is possible to leave some fields empty in a tuple. This is essentially
a function that expects the empty fields and returns the whole tuple. This is
best demonstated by the types of the examples above:
\begin{verbatim}
(42, ) : A => Int x A
(, 3.14, ) : A x B => A x Real x B
(, , "Hello from 3rd field") : A x B => A x B x String
\end{verbatim}
An example in a bigger expression is the following:
\begin{verbatim}
questions : ListOf(String)s
  = ["the Ultimate Question of Life", "the Universe", "Everything"]

answers_to : ListOf(String)s
  = apply("The answer to " +)to_all(questions)

>> apply((42, ))to_all(answers_to)
  : ListOf(Int x String)s
  = [ (42, "The answer to the Ultimate Question of Life")
    , (42, "The answer to the Universe")
    , (42, "The answer to Everything")
    ]
\end{verbatim}

\item \textit{Grammar}
\begin{grammar}
<tuple> ::= `(' [ <line-expr> ] <comma> <line-or-empty-exprs> `)'

<line-or-empty-exprs> ::=
<comma>* <line-expr> (<comma> [ <line-expr> ])*

<line-expr> ::= <no-paren-op-arg> | <line-op-expr> | <line-func-expr>

<comma> ::= `,' [ `\ ' ]
\\

<big-tuple> ::= ""\\
`(' [ `\ ' ]  [ <line-expr> ] [ <nl> <indent> ] <comma> <line-or-empty-exprs> \\
( <nl> <indent> <comma> <line-or-empty-exprs> )* 
<nl> <indent> `)'
\end{grammar}

\end{itemize}

\paragraph{Lists}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
[1, 2, 17, 42, -100]
[1.61, 2.71, 3.14, -1234.567]
["Hello World!", "What's up, doc?", "Alrighty then!"]
[x => x + 1, x => x + 2, x => x + 3]
[x, y, z, w]
\end{verbatim}

\item \textit{Description}

Lists are used to group many values of the same type into one. 
The type of the list is ListOf(A)s where A is the type of every value inside.
Therefore, the types of the first four examples are:
\begin{verbatim}
ListOf(Int)s
ListOf(Real)s
ListOf(String)s
(A)And(Int)Add_To(B) ==> ListOf(A => B)s
\end{verbatim}
And the last list is only legal if x, y, z and w all have the same type. Assuming 
they do and it's the type T, the type of the list is: 
\begin{verbatim}
ListOf(T)s
\end{verbatim}

\item \textit{Big Lists}
  \\\\
  \textbf{Example}

  \begin{verbatim}
my_big_list : ListOf(Int => IO)s
  = [ x => print("I'm the first function and x + 1 is: " + (x + 1))
    , x => print("I'm the second function and x + 2 is: " + (x + 2))
    , x => print("I'm the third function and x + 3 is: " + (x + 3))
    ]
  \end{verbatim}

  \textbf{Description} 

  It is possible to stretch a (big) list expression over multiple lines (only) in
  a seperate value definition (see "Value Definitions" section
  \ref{subsubsec:valdefs}).  In that case:
  \begin{itemize}
  \item
  The character '[' is after the "= " part of the value definition
  and the first element must be in the same line.

  \item
  The list can split in a new line only at a ',' character. Every such line must
  be indented so that the ',' is in same column where the '[' character was in
  the first line.

  \item
  The tuple must be ended by a line that only contains the ']' character and is 
  also indented so that the ']' is in same column where the '[' character was in
  the first line.

  \item
  The precise indentation rules are described in the section
  "Indentation System" \ref{subsubsec:indsys}.
  \end{itemize}

\item \textit{Grammar}
\begin{grammar}
<list> ::= `[' [ <line-exprs> ] `]'

<line-exprs> ::= <line-expr> ( <comma> <line-expr> )*

<big-list> ::= 
`[' [ `\ ' ] <line-exprs> ( <nl> <indent> <comma> <line-exprs> )* <nl> <indent> `]'
\end{grammar}

\end{itemize}

\subsubsection{Parenthesis Function Application}
\label{subsec:parenfuncapp}

\begin{itemize}
\item \textit{Examples}

\begin{verbatim}
f(x)
f(x, y, z)
(x)to_string
apply(f)to_all
apply(f)to_all(l)
\end{verbatim}

\item \textit{Description}

Function application in lcases can be done in many different ways in an attempt to 
maximize readability. In this section, we discuss the ways function application can
be done with parenthesis.
\\\\
In the first two examples, we have the usual mathematical
function application which is also used in most programming languages and
should be familiar to the reader, i.e. function application is done with the 
arguments of the function in parenthesis seperated by commas and \textbf{appended}
to the function identifier.
\\\\
We extend this idea by allowing the arguments to be \textbf{prepended} to the
function identifier (third example). Finally, it is also possible to to have
the arguments \textbf{inside} the function identifier provided the function has
been \textbf{defined with parentheses inside the identifier}. For example,
below is the definition of "apply()to\_all":

\begin{verbatim}
apply()to_all : (A => B) x ListOf(A)s => ListOf(B)s
  = (f, cases)
    empty_l => empty_l
    non_empty_l:l => non_empty_l:(f <- l.head, apply(f)to_all <- l.tail)
\end{verbatim}
The actual definition doesn't matter at this point, what matters is that the 
identifier is "apply()to\_all" with the parentheses \textbf{included}. This is very
useful for defining functions where the argument in the middle makes the function
application look and sound more like natural language.
\\\\
It is possible to have many parentheses in a single function application (last
example). The arguments are always inserted to the function from \textbf{left
to right}.  Therefore, when multiple parentheses are present the arguments of
the leftmost parentheses are inserted first then the next ones to the right and
so on.

\item \textit{Empty arguments in Parenthesis Function Application}
\\\\
It is possible to give a function only some of the arguments and the resulting
expression is a function that expects the rest of the arguments to return the final
result. Let's see this in action:
\begin{verbatim}
f : Char x Int x Real => String
c, i, r : Char, Int, Real

f(c, i, r) : String

f(, i, r) : Char => String
f(c, , r) : Int => String
f(c, i, ) : Real => String

f(c, , ) : Int x Real => String
f(, i, ) : Char x Real => String
f(, , r) : Char x Int => String
\end{verbatim}

The missing arguments after the last existing argument can be omitted and therefore
the following are equivalent to the last three above:

\begin{verbatim}
f(c) : Int x Real => String
f(, i) : Char x Real => String
f(, , r) : Char x Int => String
\end{verbatim}

\item \textit{Grammar}
\begin{grammar}
<paren-func-app> ::= ""\\""
[ <arguments> ] <identifier-with-arguments> [ <arguments> ]
\alt " "<arguments> <identifier> [ <arguments> ]
\alt " "<identifier> <arguments>

<arguments> ::= `(' <line-or-empty-exprs> `)'

<identifier-with-arguments> ::= ""\\""
[a-z] [a-z_]* ( `()'[a-z_]+ )* <arguments>
[a-z_]+ ( ( `()' | <arguments> ) [a-z_]+ )* 
[ [0-9] ]
\end{grammar}

\end{itemize}

\subsubsection{Prefix and Postfix Functions}
 
\paragraph{Prefix Functions}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
the_value:1
non_empty_l:l
error:e
result:r
apply(the_value:)to_all
\end{verbatim}

\item \textit{Description}

Prefix functions are automatically generated from \texttt{or_type} definitions
(see "Or Types" in section \ref{subsubsec:tdefs}). They are functions that
convert a value of a particular type to a value that is a case of an
\texttt{or_type} and has values of this type inside. For example in the
first example above we have:
\begin{verbatim}
1 : Int
the_value:1 : Possibly(Int)
\end{verbatim}
Where the function \texttt{thevalue:} is automatically generated from the
definition of the \texttt{Possibly} type:
\begin{verbatim}
or_type Possibly(A)
values
  the_value:A | no_value
\end{verbatim}
And it has the type \texttt{A => Possibly(A)}.
\\\\
These functions are called prefix functions because they are prepended to
their argument. However, they can also be used as any other function.
An illustration of the aforementioned is the last example, where the function
\texttt{the_value:} is an argument of the function \texttt{apply()to_all}.
Prefix functions always end with a colon.

\item \textit{Grammar}
\begin{grammar}
<pre-func> ::= <identifier> `:'

<pre-func-app> ::=
<pre-func> ( <basic-expr> | <paren-expr> | <pre-func-app> | <post-func-app> )

<basic-expr> ::=
<literal> | <identifier> | <special-id> | <tuple> | <list> | <paren-func-app>

<special-id> ::= `1st' | `2nd' | `3rd' | `4th' | `5th'
\end{grammar}

\end{itemize}

\paragraph{Postfix Functions}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
name.first_name
list.head
date.year
tuple.1st
apply(.1st)to_all
\end{verbatim}

\item \textit{Description} 

Postfix functions are automatically generated from \texttt{tuple_type}
definitions (see "Tuple Types" in section \ref{subsubsec:tdefs}). They are
functions that take a \texttt{tuple_type} value and return a particular field
(i.e. projection functions). For example in the first example above we have:
\begin{verbatim}
name : Name
name.first_name : String
\end{verbatim}
Where the function \texttt{.first_name} is automatically generated from the
definition of the \texttt{Name} type:
\begin{verbatim}
tuple_type Name
value
  (first_name, last_name) : String^2
\end{verbatim}
And it has the type \texttt{Name => String}.
\\\\
There are also the following special projection functions that work on tuples
(i.e. product type or tuple type values): \texttt{.1st .2nd .3rd .4th .5th}.
For the 4th example above, assuming:
\begin{verbatim}
tuple : Int x String
\end{verbatim}
We have:
\begin{verbatim}
tuple.1st : Int
\end{verbatim}
The general types of these functions are:
\begin{verbatim}
.1st : (A)Is(B)s_1st ==> B => A
.2nd : (A)Is(B)s_2nd ==> B => A
...
\end{verbatim}
These functions are called postfix functions because they are appended to
their argument. However, they can also be used as any other function.
An illustration of the aforementioned is the last example, where the function
\texttt{.1st} is an argument of the function \texttt{apply()to_all}.
Postfix functions always begin with a dot.
\\\\
The are a special postfix function called "\texttt{.change}" which is described in
the following paragraph.

\item \textit{Grammar}
\begin{grammar}
<post-func> ::= `.' ( <identifier> | <special-id> | <change> )

<post-func-app> ::= ( <paren-expr> | <basic-expr> ) <post-func>+
\end{grammar}

\end{itemize}

\paragraph{The ".change" Function}

\begin{itemize}

\item \textit{Examples}

\begin{verbatim}
tuple.change{1st = 42, 3rd = 17}
state.change{counter = counter + 1} 
name.change{last_name = "Gauss"}
point.change{x = 1.61, y = 2.71, z = 3.14}
apply(.change{1st = 1st + 1})to_all
\end{verbatim}

\item \textit{Description} \\\\
The "\texttt{.change}" function is a special postfix function that works an all
tuples (i.e. product type or tuple type values). It returns a new tuple that is
the input tuple with some fields changed. Which fields are going to change and
to what new value is specified inside curly brackets after the
"\texttt{.change}". The following special identifiers can be used for referring
to the fields: \texttt{1st 2nd 3rd 4th 5th} (1st and 5th example). If the tuple
is of a tuple type, the identifiers of the fields specified in the type
definition can be used (examples 2, 3 and 4). Therefore, we are assuming the
following (or similar) if the examples are to type check:

\begin{verbatim}
tuple : Int x ... x Int (optionally more: x ... ) or some equivalent tuple type

tuple_type MyStateType
value
  (..., counter, ...) : ... x Int x ...

state : MyStateType

tuple_type MyNameType
value
  (..., last_name, ...) : ... x String x ...

name : MyNameType

tuple_type Point
value
  (x, y, z) : Real^3

point : Point

apply(.change{1st = 1st + 1})to_all
  : ListOf(A)s => ListOf(A)s
  where A must be some product or tuple type where the first field can be added 
  with an integer
\end{verbatim}
The changes of the fields have the following structure: "field = expression of
new value" and they are seperated by commas. The input tuple's fields (i.e. the
"old" values) can be used inside the expression of a new value and they are
referred to by the field identifier.
\item \textit{Grammar}

\begin{grammar}
<change> ::= `change{' <field-change> ( <comma> <field-change> )* `}'

<field-change> ::= ( <identifier> | <special-id> ) `\ =\ ' <line-expr>
\end{grammar} 

\end{itemize}

\subsection{Operators}

\subsubsection{Function Application and Function Composition Operators}

\paragraph{Function Application Operators}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{->} & A x (A \ra B) \ra B \\
\hline
\texttt{<-} & (A \ra B) x A \ra B \\
\hline
\end{tabular}
\end{center}
The function application operators "\texttt{->}" and "\texttt{<-}" are a
different way to apply functions to arguments than the usual parenthesis
function application.  They are meant to look like arrows that point from the
argument to the function.  These operators are very useful for chaining many
function applications without the clutter of having to open and close
parentheses for each one of the functions.  For example, assuming we have the
following functions with the behaviour suggested by their names and types:
\begin{verbatim}
apply()to_all : (A => B) x ListOf(A)s => ListOf(B)s
string_length : String => Int
filter_with : (A => Bool) x ListOf(A)s => ListOf(A)s
is_odd : Int => Bool
sum_ints : ListOf(Int)s => Int
\end{verbatim}
And a list of strings:
\begin{verbatim}
strings : ListOf(String)s
\end{verbatim}
Here is a simple way to get the total number of characters in all the strings
that have odd length:
\begin{verbatim}
chars_in_odd_length_strings : Int
  = strings -> apply(string_length)to_all -> filter_with(is_odd) -> sum_ints
\end{verbatim}
This can be done equivalently using the other operator:
\begin{verbatim}
chars_in_odd_length_strings : Int
  = sum_ints <- filter_with(is_odd) <- apply(string_length)to_all <- strings

\end{verbatim}
These operators can also be used together to put a function between two arguments
if that function is commonly used that way in math (or if it looks better for a
certain function). For example the "mod" function can be used like so:
\begin{center}
\texttt{x -> mod <- y}
\end{center}
Which is equivalent to:
\begin{center}
\texttt{mod(x, y)}
\end{center}

\paragraph{Function Composition Operators}
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{o>} & (A \ra B) x (B \ra C) \ra (A \ra C) \\
\hline
\texttt{<o} & (B \ra C) x (A \ra B) \ra (A \ra C) \\
\hline
\end{tabular}
\end{center}
The function composition operators "\texttt{o>}" and "\texttt{<o}" are used to 
compose functions, each one in the corresponding direction. The use of the letter 'o'
is meant to be similar to the mathematical function composition symbol '\(\circ\)'
and the symbols '\texttt{>}', '\texttt{<}' are used so that the operator points from
the function which is applied first to the function which is applied second.
A neat example using function composition is the following. Assuming we have the
following functions with the behaviour suggested by their names and types: 
\begin{verbatim}
split_to_words : String => ListOf(String)s
apply()to_all : (A => B) x ListOf(A)s => ListOf(B)s
reverse_string : String => String
merge_words : ListOf(String)s => String
\end{verbatim}
We can reverse the all the words in a string like so:
\begin{verbatim}
reverse_words : String => String
  = split_to_words o> apply(reverse_string)to_all o> merge_words
\end{verbatim}
This can be done equivalently using the other operator:
\begin{verbatim}
reverse_words : String => String
  = merge_words <o apply(reverse_string)to_all <o split_to_words
\end{verbatim}


\subsubsection{Arithmetic, Comparison and Boolean Operators}

\paragraph{Arithmetic Operators}
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{\^} & (A)To_The(B)Has_Type(C) \Ra A x B \ra C \\
\hline
\texttt{*} & (A)And(B)Multiply_To(C) \Ra A x B \ra C \\
\hline
\texttt{/} & (A)Divided_By(B)Has_Type(C) \Ra A x B \ra C \\
\hline
\texttt{+} & (A)And(B)Add_To(C) \Ra A x B \ra C \\ 
\hline
\texttt{-} & (A)Minus(B)Has_Type(C) \Ra A x B \ra C \\
\hline
\end{tabular}
\end{center}
The usual arithmetic operators work as they are expected, similarly to
mathematics and other programming languages for the usual types. However, they
are generalized. The examples below show their generality:
\begin{verbatim}
>> 1 + 1
  : Int
  = 2
>> 1 + 3.14
  : Real
  = 4.14
>> 'a' + 'b'
  : String
  = "ab"
>> 'w' + "ord"
  : String
  = "word"
>> "Hello " + "World!"
  : String
  = "Hello World!"
>> 5 * 'a'
  : String
  = "aaaaa"
>> 5 * "hi"
  : String
  = "hihihihihi"
>> "1,2,3" - ','
  : String
  = "123"
\end{verbatim}
Let's analyze further the example of addition. The type can be read as such:
the '+' operator has the type \\ A x B \ra C, provided that the type
proposition (A)And(B)Add_To(C) holds. This proposition being true, means that
addition has been defined for these three types (see section "Type Logic"
\ref{subsec:typelogic} for more on type propositions). For example, by the examples
above we can deduce that the following propositions are true (in the order of the 
examples):
\begin{verbatim}
(Int)And(Int)Add_To(Int)
(Int)And(Real)Add_To(Real)
(Char)And(Char)Add_To(String)
(Char)And(String)Add_To(String)
(Int)And(Char)Multiply_To(String)
(Int)And(String)Multiply_To(String)
(String)Minus(Char)Has_Type(String)
\end{verbatim}
This allows us to use the familiar arithmetic operators in types that are not
necessarily numbers but it is somewhat intuitively obvious what the should do
in those other types. Furthermore, their behaviour can be defined by the user
for new user defined types!

\paragraph{Comparison and Boolean Operators}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{=} & (A)And(B)Can_Be_Equal \Ra A x B \ra Bool \\
\hline
\texttt{!=} & (A)And(B)Can_Be_Unequal \Ra A x B \ra Bool \\
\hline
\texttt{>=} & (A)Can_Be_Gr_Or_Eq_To(B) \Ra A x B \ra Bool \\
\hline
\texttt{<=} & (A)Can_Be_Le_Or_Eq_To(B) \Ra A x B \ra Bool \\
\hline
\texttt{>} & (A)Can_Be_Greater_Than(B) \Ra A x B \ra Bool \\
\hline
\texttt{<} & (A)Can_Be_Less_Than(B) \Ra A x B \ra Bool \\
\hline
\texttt{\& |} & Bool\texttt{\^}2 \ra Bool \\
\hline
\end{tabular}
\end{center}
Comparison operators are also generalized. The main reason for the
generalization is to be able to compare numbers of different types. Consider
the following example:

\begin{verbatim}
>> 1
  : Int
  = 1
>> 1.1
  : Real
  = 1.1
>> 1.1 = 1
  : Bool
  = false
\end{verbatim}
In order for the example to work we need to be able to compare integers and
reals.  Similarly, all the comparison operators need to be able to work on
arguments of different types. Other than that, the comparison and boolean
operators behave similarly to most programming languages. It's also worth
noting that the "equals", "and" and "or" operators have the symbol once
(\texttt{= \& |}) instead of twice (\texttt{== \&\& ||}).

\subsubsection{Environment Action Operators}
\label{subsec:envacts}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type \\ 
\hline
\hline
\texttt{;>} & (E)Has_Use \Ra E(A) x (A \ra E(B)) \ra E(B) \\
\hline
\texttt{;} & (E)Has_Then \Ra E(A) x E(B) \ra E(B) \\
\hline
\end{tabular}
\end{center}

\paragraph{Simple Example}
\begin{verbatim}
print_string("I'll repeat the line.") ; get_line ;> print_string
\end{verbatim}
The example above demonstrates the use of the environment action operators with
the \texttt{FromIO} type, which is how IO is done in lcases. Some light can
be shed on how this is done, if we take a look at the types (as always!):
\begin{verbatim}
print_string : String => (EmptyVal)FromIO
print_string("I'll repeat the line.") : (EmptyVal)FromIO
get_line : (String)FromIO

; 
  : (E)Has_Then ==> E(A) x E(B) => E(B) 
;>
  : (E)Has_Use ==> E(A) x (A => E(B)) => E(B) 

print_string("I'll repeat the line.") ; get_line
  : (String)FromIO
  where (FromIO)Has_Then is true, E = FromIO, A = EmptyVal, B = String

print_string("I'll repeat the line.") ; get_line ;> print_string
  : (EmptyVal)FromIO
  where (FromIO)Has_Use is true, E = FromIO, A = String, B = EmptyVal
\end{verbatim}

\paragraph{Example program}
\begin{verbatim}
main : (EmptyVal)FromIO
  = print_string <- "Hello! What's your name?" ; get_line ;> name =>
    print_string("Oh hi " + name + "! What's your age?") ; get_line ;> age =>
    print_string("Oh that's crazy " + name + "! I didn't expect you to be " + age + "!");
\end{verbatim}
In this bigger but similar example the types are:
\begin{verbatim}
print_string : String => (EmptyVal)FromIO
get_line : (String)FromIO

print_string <- "Hello! ... " : (EmptyVal)FromIO
print_string("Oh hi...) : (EmptyVal)FromIO
print_string("Oh that's crazy...) : (EmptyVal)FromIO

;
  : (E)Has_Then ==> E(A) x E(B) => E(B) 

print_string("Oh hi...) ; get_line
  : (String)FromIO
  where (FromIO)Has_Then is true, E = FromIO, A = EmptyVal, B = String

age => print_string("Oh that's crazy...)
  : String => (EmptyVal)FromIO

;>
  : (E)Has_Use ==> E(A) x (A => E(B)) => E(B) 

print_string("Oh hi...) ; get_line ;> age =>
print_string("Oh that's crazy...)
  : (EmptyVal)FromIO
  where (FromIO)Has_Use is true, E = FromIO, A = String, B = EmptyVal

print_string <- "Hello..." ; get_line
  : (String)FromIO

name => print_string("Oh hi ... (till the end)
  : String => (EmptyVal)FromIO

print_string <- "Hello..." ; get_line ;> name =>
print_string("Oh hi ... (till the end)
  : (EmptyVal)FromIO
\end{verbatim}
Therefore, "\texttt{main\ :\ (EmptyVal)FromIO}" checks out.  The key here is
to remember that function expressions extend to the end of the whole
expression. Therefore, we have "\texttt{name => ... (till the end)}" and
"\texttt{age => ... (till the end)}" as the second arguments of the two
occurences of the "\texttt{;>}" operator. 

\paragraph{Description}\mbox{} \\\\
The environment action operators are used to combine values that do environment
actions into values that do more complicated environment actions. Environment
actions are type functions that take a type argument and produce a type (just
like ListOf()s). These type functions have the "then" operator (\texttt{;}) and
the "use" operator (\texttt{;>}) defined for them.  A value of the type
\texttt{E(A)} where \texttt{(E)Has_Then} does an environment action of type
\texttt{E} that produces a value of type \texttt{A} which can then be combined
with another one with the "then" operator. Similarly, with the "use" operator
the produced value of an action can be used by a function that returns another
action.
\\\\
The effect of the "\texttt{;}" operator described in words is the following:
given a value of type \texttt{E(A)} and a value of type \texttt{E(B)} (which
do environment actions that produce values of type \texttt{A} and \texttt{B}
respectively), create a new value the does both actions (provided the first did
not result in an error).  The overall effect is a value that does an
environment action of type \texttt{E} (the combination of the "smaller"
actions) which produces a value of type \texttt{B} (the one produced by the second
action) and therefore it is of type \texttt{E(B)}.
\\\\
Note that the value of type \texttt{A} produced by the first action is not used
anywhere. This happens mostly when \texttt{A = EmptyVal} and it is 
because values of type \texttt{E(EmptyVal)} are used for their environment
action only \\(e.g. \texttt{print_string(...)\ :\ (EmptyVal)FromIO}).
\\\\
How the two environment actions of the \texttt{E(A)} and \texttt{E(B)} values
are combined to produce the new environment action is specific to the
environment action type \texttt{E}.
\\\\
The effect of the "\texttt{;>}" operator described in words is the following:
given a value of type \texttt{E(A)} (which does an environment action of type
\texttt{E} that produces a value of type \texttt{A}) and a value of type
\texttt{A => E(B)} (which is a function that takes a value of type \texttt{A}
and returns an environment action of type \texttt{E} that produces a value
of type \texttt{B}), combine those two values by creating a value that does the
following: 
\begin{itemize}
\item
Performs the first action that produces a value of type \texttt{A}

\item
Takes the value of type \texttt{A} produced (provided there was no error) and
passes it to the function of type \texttt{A => E(B)} that then returns an
action

\item
Perfoms the resulting action 
\end{itemize}
The overall effect is an environment action  of type \texttt{E} that in the end
produces a value is of type \texttt{B} and therefore the new value is of type
\texttt{E(B)}.

\subsubsection{Operator Expressions}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
1 + 2
1 + x * 3^y
"Hello " + "World!"
x -> f -> g
f o> g o> h
x = y
x >= y - z & x < 2 * y
get_line ; get_line ;> line => print("Second line: " + line)
\end{verbatim}

\item \textit{Description}

Operator expressions are expressions that use operators. Operators act like
two-argument-functions that are placed in between their arguments. Therefore,
they have function types and they act as it is described in their respective
sections above this one.
\\\\
An operator expression might have multiple operators. The order of operations
is explained in the next section ("Complete Table, Precedence and Associativity")
in Table \ref{table:precassoc}.
\\\\
Just like functions, the sub-expressions
that act as arguments to an operator, must have types that match the types 
expected by the operator.
\\\\
It is possible for the second argument of an operator to be a function expression.
This is mostly useful with the "\texttt{;>}" operator (see previous section:
"Environment Operators"), but it is also possible with the following operators:
"\texttt{->}", "\texttt{o>}", "\texttt{<o}".

\item \textit{Big Operator Expressions}\\\\
\textbf{Example}

\begin{verbatim}
"Hello, I'm a big string that's going to contain multiple values from " +
"inside the imaginary program that I'm a part of. Here they are:\n" +
"value1 = " + value1 + ", value2 = " + value2 + ", value3 = " + value3 + 
", value4 = " + value4 + ", value5 = " + value5
\end{verbatim}

\textbf{Description}

It is possible to stretch a (big) operator expression over multiple lines.
In that case:
\begin{itemize}
\item
The operator expression must split in a new line after an operator (not an
argument).

\item
Every line after the first must be indented so that in begins at the column 
where the first line of the operator expression begun.

\item
The precise indentation rules are described in the section
"Indentation System" \ref{subsubsec:indsys}.
\end{itemize}

\item \textit{Grammar}
\begin{grammar}
<op-expr> ::= <line-op-expr> | <big-op-expr>
\\

<op-expr-start> ::= ( <op-arg> <op> )+

<line-op-expr> ::= <op-expr-start> ( <op-arg> | <line-func-expr> )
\\

<big-op-expr> ::= 
<big-op-expr-op-split> | <big-op-expr-func-split>
\\

<big-op-expr-op-split> ::= 
<op-split-line>+ [ <op-expr-start> ] ( <op-arg> | <func-expr> )

<op-split-line> ::=
<op-expr-start> ( <nl> | <op-arg> <comp-op-nl> ) <indent> 
\\

<big-op-expr-func-split> ::= <op-expr-start> ( <big-func-expr> | <cases-func-expr> )
\\

<op-arg> ::= <no-paren-op-arg> | <paren-expr>

<no-paren-op-arg> ::=
<basic-expr> | <pre-func> | <post-func> | <pre-func-app> | <post-func-app>
\\

<op> ::=  
`\ ' ( `o>' | `<o' ) `\ ' | [ `\ ' ] <optional-spaces-op> [ `\ ' ]

<optional-spaces-op> ::= 
`->' | `<-' | `^' | `*' | `/' | `+' | `-' | `=' | `!=' | `>' | `<' | `>=' | `<=' |
`\&' | `|' | `;>' | `;'
\\

<comp-op-nl> ::= `\ ' ( `o>' | `<o' ) `\\n'
\end{grammar}
\end{itemize}

\newpage
\subsubsection{Complete Table, Precedence and Associativity}

\begin{table}[h]

\caption{
The complete table of lcases operators along with their types and 
their short descriptions.
}

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Type & Description \\ 
\hline
\hline
\texttt{->} & A x (A \ra B) \ra B & Right function application \\
\hline
\texttt{<-} & (A \ra B) x A \ra B & Left function application \\
\hline
\texttt{o>} & (A \ra B) x (B \ra C) \ra (A \ra C) & Right function composition \\
\hline
\texttt{<o} & (B \ra C) x (A \ra B) \ra (A \ra C) & Left function composition \\
\hline
\texttt{\^} & (A)To_The(B)Has_Type(C) \Ra A x B \ra C & General exponentiation  \\
\hline
\texttt{*} & (A)And(B)Multiply_To(C) \Ra A x B \ra C & General multiplication  \\
\hline
\texttt{/} & (A)Divided_By(B)Has_Type(C) \Ra A x B \ra C & General division \\
\hline
\texttt{+} & (A)And(B)Add_To(C) \Ra A x B \ra C & General addition \\ 
\hline
\texttt{-} & (A)Minus(B)Has_Type(C) \Ra A x B \ra C & General subtraction \\
\hline
\texttt{=} & (A)And(B)Can_Be_Equal \Ra A x B \ra Bool & General Equality \\
\hline
\texttt{!=} & (A)And(B)Can_Be_Unequal \Ra A x B \ra Bool & General Inequality \\
\hline
\texttt{>=} & (A)Can_Be_Gr_Or_Eq_To(B) \Ra A x B \ra Bool
& General greater than or equal to \\
\hline
\texttt{<=} & (A)Can_Be_Le_Or_Eq_To(B) \Ra A x B \ra Bool
& General less than or equal to \\
\hline
\texttt{>} & (A)Can_Be_Greater_Than(B) \Ra A x B \ra Bool & General greater than \\
\hline
\texttt{<} & (A)Can_Be_Less_Than(B) \Ra A x B \ra Bool & General less than \\
\hline
\texttt{\& |} & Bool\texttt{\^}2 \ra Bool & Boolean operators \\
\hline
\texttt{;>} & (E)Has_Use \Ra E(A) x (A \ra E(B)) \ra E(B) &
Do, use, do \\
\hline
\texttt{;} & (E)Has_Then \Ra E(A) x E(B) \ra E(B) &
Do then do \\
\hline
\end{tabular}
\end{center}

\label{table:allops}

\end{table}
\newpage\noindent
The order of operations is done from highest to lowest precedence. In the same
level of precedence the order is done from left to right if the associativity
is "Left" and from right to left if the associativity is "Right". For the
operators that have associativity "None" it is not allowed to place them in the
same operator expression. The precedence and assosiativity of the operators
is shown in the table below.

\begin{table}[h]

\caption{ The table of precedence and associativity of the lcases operators.  }

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Operator & Precedence & Associativity \\ 
\hline
\hline
\texttt{->} & 10 (highest) & Left \\
\hline
\texttt{<-} & 9 & Right \\
\hline
\texttt{o> <o} & 8 & Left \\
\hline
\texttt{\^} & 7 & Right \\
\hline
\texttt{* /} & 6 & Left \\
\hline
\texttt{+ -} & 5 & Left \\ 
\hline
\texttt{= != > < >= <=} & 4 & None \\
\hline
\texttt{\&} & 3 & Left \\
\hline
\texttt{|} & 2 & Left \\
\hline
\texttt{;> ;} & 1 & Left \\
\hline
\end{tabular}
\end{center}

\label{table:precassoc}

\end{table}

\newpage
\subsection{Function Expressions}
\label{subsec:funcexprs}

Function expressions are divided into \textbf{regular function expressions} and 
\textbf{"cases" function expressions} which are described in the following sections.
\\\\
The grammar for a function expression is:
\begin{grammar}
<func-expr> ::= <line-func-expr> | <big-func-expr> | <cases-func-expr>
\end{grammar}

\subsubsection{Regular Function Expressions}

\begin{itemize}
\item \textit{Examples}

\begin{verbatim}
a => 17 * a + 42
(x, y, z) => (x^2 + y^2 + z^2)^(1 / 2)
\end{verbatim}

\item \textit{Description}

Regular function expressions are used to define functions or be part of bigger
expressions as anonymous functions. They are comprised by their parameters and
their body. A parameter has an identifier. The parameters are either
only one, in which case there is no parenthesis, or they are many, in which
case they are in parenthesis, seperated by commas. The parameters and the body
are seperated by an arrow (" \texttt{=>} "). The body is an operator
expression or an operator argument expression.

\item \textit{Big Function Expressions}\\\\
\textbf{Example}

\begin{verbatim}
(value1, value2, value3, value4, value5, value6, value7) => 
print_line("value1 = " + value1 + ", value2 = " + value2 + ", value3 = " + value3) ;
print_line("value4 = " + value4 + ", value5 = " + value5 + ", value6 = " + value6) ;
print_line("value7 = " + value7)
\end{verbatim}

\textbf{Description}

It is possible to stretch a (big) function expression over multiple lines.
In that case:
\begin{itemize}
\item
The function expression must split in a new line after the "\texttt{=>}" arrow.

\item
Every line after the first must be indented so that in begins at the column 
where the first character of the parameters was in the first line.

\item
The precise indentation rules are described in the section
"Indentation System" \ref{subsubsec:indsys}.
\end{itemize}

\item \textit{Grammar}
\begin{grammar}
<line-func-expr> ::= <parameters> `\ =>' <line-func-body>

<big-func-expr> ::= <parameters> `\ =>' <big-func-body>

<parameters> ::= <identifier> | <paren-comma-sep-ids>

<paren-comma-sep-ids> ::= `(' <identifier> ( <comma> <identifier> )+ `)'

<line-func-body> ::= `\ ' ( <no-paren-op-arg> | <line-op-expr> )

<big-func-body> ::= <nl> <indent> ( <no-paren-op-arg> | <op-expr> )
\end{grammar}
\end{itemize}

\subsubsection{"cases" Function Expressions}
\label{subsubsec:casessyntax}

\begin{itemize}
\item \textit{Examples}

\begin{verbatim}
print_sentimental_bool : Bool => IO
  = cases
    true => print <- "It's true!! :)"
    false => print <- "It's false... :("

or_type TrafficLight
values
  green | amber | red

print_sentimental_traffic_light : TrafficLight => IO
  = cases
    green => print <- "It's green! Let's go!!! :)"
    amber => print <- "Go go go, fast!"
    red => print <- "Stop right now! You're going to kill us!!"

is_not_red : TrafficLight => Bool
  = cases
    green => true
    amber => true
    red => false

is_seventeen_or_forty_two : Int => Bool
  = cases
    17 => true
    42 => true
    ... => false

traffic_lights_match : TrafficLight^2 => Bool
  = (cases, cases)
    (green, green) => true
    (amber, amber) => true
    (red, red) => true
    ... => false

gcd : Int^2 => Int
  = (x, cases)
    0 => x
    y => gcd(y, x -> mod <- y) 

is_empty : ListOf(A)s => Bool
  = cases
    empty_l => true
    non_empty_l:anything => false

apply()to_all : (A => B) x ListOf(A)s => ListOf(B)s
  = (f, cases)
    empty_l => empty_l
    non_empty_l:list => non_empty_l:(f <- list.head, apply(f)to_all <- list.tail)

\end{verbatim}

\item \textit{Description}

"cases" is a keyword that works as a special parameter. The difference is that
instead of giving the name "cases" to that parameter, it allows the programmer
to pattern match on the possible values of that parameter and return a
different result for each particular case. 
\\\\
The last case can be "\texttt{... => (body of default case)}" to capture all
remaining cases while dismissing the value (e.g.
\texttt{is_seventeen_or_forty_two} example), or it can be
"\texttt{some_id => (body of default case)}" to capture all remaining
cases while being able to use the value with the name "\texttt{some_id}"
(e.g.  "y" in \texttt{gcd} example).
\\\\
It is possible to use the "cases" keyword in multiple parameters to match on all
of them. By doing that, each case represents a particular combination of values
for the parameters involved\\(e.g. \texttt{traffic_lights_match} example).
\\\\
It is also possible to use a "where" expression below a particular case. The
"where" expression must be indented two spaces more than than the line where
that particular case begins.
\\\\
A function expression that uses the "cases" syntax must contain the "cases"
keyword in at least one parameter. The number of matching expressions in 
all cases must be the same as the number of parameters with the "cases" keyword.

\item \textit{Grammar}
\begin{grammar}
<cases-func-expr> ::= <cases-parameters> <case>+ [ <end-case> ]

<cases-parameters> ::=
<cases-parameter> | `(' <cases-parameter> ( <comma> <cases-parameter> )+ `)'

<cases-parameter> ::= <identifier> | `cases'
\\

<case> ::=  <nl> <indent> <matching> `\ =>' <case-body>

<end-case> ::= <nl> <indent> `...\ =>' <case-body>
\\

<matching> ::= 
<literal> | <identifier> | <pre-func> <matching> | <tuple-matching> |
<list-matching>

<tuple-matching> ::= `(' <matching> ( <comma> <matching> )+ `)'

<list-matching> ::= `[' [ <matching> ( <comma> <matching> )* ] `]'
\\

<case-body> ::= ( <line-func-body> | <big-func-body> ) [ <where-expr> ]
\end{grammar}

\end{itemize}

\subsection{Value Definitions and "where" Expressions}
\label{subsec:valdefswhere}

\subsubsection{Value Definitions}
\label{subsubsec:valdefs}

\begin{itemize}

\item \textit{Examples}

\begin{verbatim}
foo : Int
  = 42

f : Int^3 => Int
  = (a, b, c) => a + b * c

val1, val2, val3 : Int, Bool, Char
  = 42, true, 'a'

int1, int2, int3 : all Int
  = 1, 2, 3
\end{verbatim}

\item \textit{Description}

Value definitions are the main building block of lcases programs. To define a
new value you give it a name, a type and an expression. The name is an
identifier in the first line. The second line is indented two spaces more and
begins by ": " and continues with the type expression. The third line is
indented as the second, begins by "= " and continues with the value
expression (which extends to as many lines as needed).
\\\\
A value definition is either in the first column, where it can be "seen" by all
other value definitions, or it is in a "where" expression (see section below),
where it can be "seen" by the expression above the "where" and all the other
definitions in the same "where" expression.
\\\\
A value definition can be followed by a "where" expression where intermediate
values used in the value expression are defined. In that case, the "where"
expression must be indented two spaces more than the "=" line of the value
definition.
\\\\
It is possible to group value definitions together by seperating the names, the
types and the expressions with commas. This is very useful for not cluttering
the program with many definitions for values with small expressions (e.g.
constants).  When grouping definitions together it is also possible to use the
keyword "all" to give the same type to all the values.

\item \textit{Grammar}
\begin{grammar}
<value-def> ::= ""\\
<indent> <identifier> 
( ` ' | <nl> <indent> ) `:\ ' <type> 
<nl> <indent> `=\ ' <value-expr> [ <where-expr> ]

<value-expr> ::=
<no-paren-op-arg> | <op-expr> | <func-expr> | <big-tuple> | <big-list>

<grouped-value-defs> ::= ""\\
<indent> <identifier> ( <comma> <identifier> )+ \\
( ` ' | <nl> <indent> ) `:\ ' ( <type> ( <comma> <type> )+ | `all\ ' <type> ) \\
<nl> <indent> `=\ ' <line-exprs> ( <nl> <indent> <comma> <line-exprs> )*
\end{grammar}

\end{itemize}

\subsubsection{"where" Expressions}

\begin{itemize}

\item \textit{Examples}
\begin{verbatim}
sort : ListOf(Int)s => ListOf(Int)s
  = cases
    empty_l => empty_l
    non_empty_l:l => sort(less_l) + l.head + sort(greater_l)
      where
      less_l, greater_l : all ListOf(Int)s
        = filter_with(x => x < l.head, l.tail)
        , filter_with(x => x >= l.head, l.tail)

sum_nodes : TreeOf(Int)s => Int
  = tree => tree.root + tree.subtrees -> apply(sum_nodes)to_all -> sum_list
    where
    sum_list : ListOf(Int)s => Int
      = cases
        empty_l => 0
        non_empty_l:l => l.head + sum_list(l.tail)

big_string : String
  = s1 + s2 + s3 + s4
    where
    s1, s2, s3, s4 : all String
      = "Hello, my name is Struggling Programmer."
      , "I have tried way too many times to fit a big chunk of text"
      , "inside my program, without it hitting the half-screen mark!"
      , "I am so glad I finally discovered lcases!"
\end{verbatim}

\item \textit{Description}

"where" expressions allow the programmer to use values inside an expression and
define them below it. They are very useful for reusing or abbreviating
expressions that are specific to a particular definition or case.
\\\\
A "where" expression begins by a line that only has the word "where" in it. It is
indented as described in the "Value Definitions" (\ref{subsubsec:valdefs}) or
"'cases' Function Expressions" (\ref{subsubsec:casessyntax}) sections.  The
definitions are placed below the "where" line and must have the same
indentation. 

\item \textit{Grammar}
\begin{grammar}
<where-expr> ::=
<nl> <indent> `where' <nl> <value-def-or-defs> ( <nl> <nl> <value-def-or-defs> )*

<value-def-or-defs> ::= <value-def> | <grouped-value-defs> 
\end{grammar}

\end{itemize}

\subsection{Indentation and Complete Grammar for Values}

\subsubsection{Indentation System}
\label{subsubsec:indsys}

The \textit{$<$indent$>$} nonterminal in not a normal BNF nonterminal. It is a
context sensitive construct that enforces the indentation rules of lcases.
It depends on a integer value called the "indentation level" ($il$).
The \textit{$<$indent$>$} nonterminal corresponds to $2*il$ space characters.
The indentation level follows the rules below:

\paragraph{Indentation Rules}
\begin{itemize}

\item
At the beginnng: $il = 0$.

\item
At the end of the first line of a value definition: $il \leftarrow il + 1$.
This also applies to grouped value definitions.

\item
At the end of the third line ("=" line) of a (single) value definition: $il
\leftarrow il + 1$.

\item
At the end of a (single) value definition: $il \leftarrow il - 2$.

\item
At the end of grouped value definitions: $il \leftarrow il - 1$.

\item
After the "\texttt{=>}" arrow in a case: $il \leftarrow il + 1$.

\item
At the end of a case body: $il \leftarrow il - 1$.

\item
In a cases function expression which does not begin at the "=" line of a value
definition:
  \begin{itemize}

  \item
  After the arrow "\texttt{=>}" at the end of the paremeters: $il \leftarrow il + 1$.

  \item
  At the end of the cases function expression: $il \leftarrow il - 1$.

  \end{itemize}

\item
In a type theorem (section \ref{subsubsec:ttheo}),
if the value expression is a big or cases expression: 
  \begin{itemize}

  \item
  After "\texttt{=}" line: $il \leftarrow il + 2$.

  \item
  After the value expression: $il \leftarrow il - 2$.
  \end{itemize}

\end{itemize}

\subsubsection{Complete Grammar for Values}
\begin{grammar}

<literal> ::= <int-lit> | <real-lit> | <char-lit> | <string-lit>
\\

<identifier> ::= [a-z] [a-z_]* ( `()' [a-z_]+ )* [ [0-9] ]
\\

<paren-expr> ::= `(' <line-op-expr> | <line-func-expr> `)'  
\\

<tuple> ::= `(' [ <line-expr> ] <comma> <line-or-empty-exprs> `)'

<line-or-empty-exprs> ::=
<comma>* <line-expr> (<comma> [ <line-expr> ])*

<line-expr> ::= <no-paren-op-arg> | <line-op-expr> | <line-func-expr>

<comma> ::= `,' [ `\ ' ]
\\

<big-tuple> ::= ""\\
`(' [ `\ ' ]  [ <line-expr> ] [ <nl> <indent> ] <comma> <line-or-empty-exprs> \\
( <nl> <indent> <comma> <line-or-empty-exprs> )* 
<nl> <indent> `)'
\\

<list> ::= `[' [ <line-exprs> ] `]'

<line-exprs> ::= <line-expr> ( <comma> <line-expr> )*

<big-list> ::= 
`[' [ `\ ' ] <line-exprs> ( <nl> <indent> <comma> <line-exprs> )* <nl> <indent> `]'
\\

<paren-func-app> ::= ""\\""
[ <arguments> ] <identifier-with-arguments> [ <arguments> ]
\alt " "<arguments> <identifier> [ <arguments> ]
\alt " "<identifier> <arguments>

<arguments> ::= `(' <line-or-empty-exprs> `)'

<identifier-with-arguments> ::= ""\\""
[a-z] [a-z_]* ( `()'[a-z_]+ )* <arguments>
[a-z_]+ ( ( `()' | <arguments> ) [a-z_]+ )* 
[ [0-9] ]
\\

<pre-func> ::= <identifier> `:'

<pre-func-app> ::=
<pre-func> ( <basic-expr> | <paren-expr> | <pre-func-app> | <post-func-app> )

<basic-expr> ::=
<literal> | <identifier> | <tuple> | <list> | <paren-func-app> | <special-id>
\\

<post-func> ::= `.' ( <identifier> | <special-id> | <change> )

<special-id> ::= `1st' | `2nd' | `3rd' | `4th' | `5th'

<post-func-app> ::= ( <paren-expr> | <basic-expr> ) <post-func>+
\\

<change> ::= `change{' <field-change> ( <comma> <field-change> )* `}'

<field-change> ::= ( <identifier> | <special-id> ) `\ =\ ' <line-expr>
\\

<op-expr> ::= <line-op-expr> | <big-op-expr>
\\

<op-expr-start> ::= ( <op-arg> <op> )+

<line-op-expr> ::= <op-expr-start> ( <op-arg> | <line-func-expr> )
\\

<big-op-expr> ::= 
<big-op-expr-op-split> | <big-op-expr-func-split>
\\

<big-op-expr-op-split> ::= 
<op-split-line>+ [ <op-expr-start> ] ( <op-arg> | <func-expr> )

<op-split-line> ::=
<op-expr-start> ( <nl> | <op-arg> <comp-op-nl> ) <indent> 
\\

<big-op-expr-func-split> ::= <op-expr-start> ( <big-func-expr> | <cases-func-expr> )
\\

<op-arg> ::= <no-paren-op-arg> | <paren-expr>

<no-paren-op-arg> ::=
<basic-expr> | <pre-func> | <post-func> | <pre-func-app> | <post-func-app>
\\

<op> ::=  
`\ ' ( `o>' | `<o' ) `\ ' | [ `\ ' ] <optional-spaces-op> [ `\ ' ]

<optional-spaces-op> ::= 
`->' | `<-' | `^' | `*' | `/' | `+' | `-' | `=' | `!=' | `>' | `<' | `>=' | `<=' |
`\&' | `|' | `;>' | `;'
\\

<comp-op-nl> ::= `\ ' ( `o>' | `<o' ) `\\n'
\\

<func-expr> ::= <line-func-expr> | <big-func-expr> | <cases-func-expr>
\\

<line-func-expr> ::= <parameters> `\ =>' <line-func-body>

<big-func-expr> ::= <parameters> `\ =>' <big-func-body>

<parameters> ::= <identifier> | <paren-comma-sep-ids>

<paren-comma-sep-ids> ::= `(' <identifier> ( <comma> <identifier> )+ `)'

<line-func-body> ::= `\ ' ( <no-paren-op-arg> | <line-op-expr> )

<big-func-body> ::= <nl> <indent> ( <no-paren-op-arg> | <op-expr> )
\\

<cases-func-expr> ::= <cases-parameters> <case>+ [ <end-case> ]

<cases-parameters> ::=
<cases-parameter> | `(' <cases-parameter> ( <comma> <cases-parameter> )+ `)'

<cases-parameter> ::= <identifier> | `cases'
\\

<case> ::=  <nl> <indent> <matching> `\ =>' <case-body>

<end-case> ::= <nl> <indent> `...\ =>' <case-body>
\\

<matching> ::= 
<literal> | <identifier> | <pre-func> <matching> | <tuple-matching> |
<list-matching>

<tuple-matching> ::= `(' <matching> ( <comma> <matching> )+ `)'

<list-matching> ::= `[' [ <matching> ( <comma> <matching> )* ] `]'
\\

<case-body> ::= ( <line-func-body> | <big-func-body> ) [ <where-expr> ]
\\

<value-def> ::= 
<indent> <identifier> 
( ` ' | <nl> <indent> ) `:\ ' <type> 
<nl> <indent> `=\ ' <value-expr> [ <where-expr> ]

<value-expr> ::=
<no-paren-op-arg> | <op-expr> | <func-expr> | <big-tuple> | <big-list>

<grouped-value-defs> ::= ""\\
<indent> <identifier> ( <comma> <identifier> )+ \\
( ` ' | <nl> <indent> ) `:\ ' ( <type> ( <comma> <type> )+ | `all\ ' <type> ) \\
<nl> <indent> `=\ ' <line-exprs> ( <nl> <indent> <comma> <line-exprs> )*
\\

<where-expr> ::=
<nl> <indent> `where' <nl> <value-def-or-defs> ( <nl> <nl> <value-def-or-defs> )*

<value-def-or-defs> ::= <value-def> | <grouped-value-defs> 
\end{grammar}

\section{Language Description: Types and Type Logic}

\subsection{Types}
\label{subsec:types}

The constructs regarding types are \textbf{type expressions}, \textbf{type
definitions} and \textbf{type nicknames} and they are described in the
following sections.

\subsubsection{Type Expressions}

Type expressions are divided into the following categories:
\begin{itemize}
\item Type Identifiers
\item Type Variables
\item Function Types
\item Product Types
\item Type Application Types
\item Conditional Types
\end{itemize}
which are described in the following paragraphs.
\\\\
The grammar of a type expression is:
\begin{grammar}
<type> ::= [ <condition> ]  <simple-type> 

<simple-type> ::=
<type-id> | <type-var> | <func-type> | <prod-type> | <power-type> | <type-app>
\\
\end{grammar}
\paragraph{Type Identifiers}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
Int
Real 
Char 
String
SelfReferencingType
MyDefinedType
\end{verbatim}

\item \textit{Description}

A type identifier is either the name of a basic type (Int, Real, Char, String) or
the name of some defined type that has no type parameters. It begins with a capital
letter and is followed by one or more capital or lowercase letters.

\item \textit{Grammar}
\begin{grammar}
<type-id> ::= [A-Z] [A-Za-z]+ \\ 
\end{grammar}
\end{itemize}

\paragraph{Type Variables}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
A B C
X Y Z
\end{verbatim}

\item \textit{Examples of type variables inside bigger type expressions}
\begin{verbatim}
A => A
(A => B) x (B => C) => (A => C)
(A^2 => A) x A x ListOf(A)s => A
\end{verbatim}

\item \textit{Description}

Type Variables are used inside larger type expressions of polymorphic types. A
polymorphic type is a type where any function of that type can be used as a
function of any type that corresponds to substituting every type variable of
the polymorphic type with a particular type. The easiest example of a
polymorphic type is the type of the identity function where we have:
\begin{verbatim}
id : A => A
  = x => x

id(1) : Int
  where A is substituted by Int and id gets the type Int => Int

id("Hello") : String
  where A is substituted by String and id gets the type String => String
\end{verbatim}

A type variable is a single capital letter.

\item \textit{Grammar}
\begin{grammar}
<type-var> ::= [A-Z] \\ 
\end{grammar}
\end{itemize}

\paragraph{Function Types}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
String => String 
Real => Int
A => A
Int^2 => Int
Real^3 => Real
(A => B) x (B => C) => (A => C)
(Int => Int) => (Int => Int)
\end{verbatim}

\item \textit{Description}

A function type expression is comprised of the input type expression and the
output type expression seperated by the arrow " \texttt{=>} ". The input and output
type expressions are type expressions which are put in parentheses only if they are
function type expressions. 

\item \textit{Grammar}
\begin{grammar}
<func-type> ::= <in-or-out-type> `\ =>\ ' <in-or-out-type>

<in-or-out-type> ::=
<type-id> | <type-var> | <prod-type> | <power-type> | <type-app> |
`(' <func-type> `)'
\end{grammar}
\end{itemize}

\paragraph{Product Types}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
Int x Real x String
ListOf(Int)s x Int x ListOf(String)s
(Int => Int) x (Int x Real) x (Real => String)
Int^2
Real^3
\end{verbatim}

\item \textit{Description}

Product types are the types of tuples. They are comprised of the expressions of
the types of the fields seperated by the string " x " (space 'x' space) because
'x' is very similar the symbol used in the cartesian product. If any of the
fields is of a product or a function type then the corresponding type expression
must be inside parentheses. A product type where all the fields are of the same
type can be abbreviated with a power type expression which is comprised of the 
type, the power symbol '\texttt{\^}' and the number of times the type is repeated.

\item \textit{Grammar}
\begin{grammar}
<prod-type> ::= <field-type> ( `\ x\ ' <field-type> )+

<power-type> ::= <field-type> ( `^' <int-greater-than-one> )+

<field-type> ::=
<type-id> | <type-var> | <type-app> | `(' ( <func-type> | <prod-type> ) `)'
\end{grammar}
\end{itemize}

\paragraph{Type Application Types}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
Possibly(Int)
ListOf(Real)s
TreeOf(String)s 
Error(String)OrResult(Int)
ListOf(Int => Int)s
ListOf(A)s
\end{verbatim}

\item \textit{Description}

Type application types are types that are produced by passing arguments
to a type function generated by a \texttt{tuple_type} or an \texttt{or_type}
definition. For example, given the definition of \texttt{ListOf(A)s}:
\begin{verbatim}
or_type ListOf(A)s
values
  non_empty_l:NonEmptyListOf(A)s | empty_l
\end{verbatim}
We have that \texttt{ListOf()s} is a type function that receives one type parameter
and returns a resulting type. For example \texttt{ListOf(Int)s} is the result
of passing the type argument \texttt{Int} to \texttt{ListOf()s}.
\\\\
Type application types have the same form as the name in the
\texttt{tuple_type} or \texttt{or_type} definition, with the difference that
type parameters are substituted by the type expressions of the arguments.

\item \textit{Grammar}
\begin{grammar}
<type-app> ::= ""\\""
[ <types-in-paren> ] <type-id-with-args> [ <types-in-paren> ]
\alt " "<types-in-paren> <type-id-or-var> [ <types-in-paren> ]
\alt " "<type-id-or-var> <types-in-paren>

<type-id-with-args> ::= <type-id> ( <types-in-paren> [A-Za-z]+ )+

<type-id-or-var> ::= <type-id> | <type-var>

<types-in-paren> ::= `(' <simple-type> ( <comma> <simple-type> )* `)'
\end{grammar}
\end{itemize}

\paragraph{Conditional Types}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
(A)And(B)Can_Be_Equal ==> A x B => Bool
(A)And(B)Add_To(C) ==> A x B => C
(A)Is(B)s_First ==> B => A
(T)Has_String_Repr ==> T => String
(E)Has_Use ==> E(A) x (A => E(B)) => E(B)
\end{verbatim}

\item \textit{Description}

Conditional types are the types of values that are polymorphic not because of
their structure but because they have been defined (seperately) for many
different combinations of types (i.e. they are ad hoc polymorphic). They are
comprised of a condition and a "simple" type (i.e. a type without a
condition) which are seperated by the arrow "\texttt{==>}". The condition is a
type proposition which refers to type variables inside the "simple" type
and it must hold whenever the polymorphic value of that type is used. For
example:
\begin{verbatim}
first : (A)Is(B)s_First => B => A
\end{verbatim}
can be used as follows:
\begin{verbatim}
pair, triple, list
  : Int x String, Real x Char x Int, ListOf(String)s
  = (42, "The answer to everything"), (3.14, 'a', 1), ["Hi!", "Hello", Heeey"]

>> pair -> first
  : Int
  = 42
>> triple -> first
  : Real
  = 3.14
>> list -> first
  : String
  = "Hi!"
\end{verbatim}
and that is because the following propositions hold:
\begin{verbatim}
(Int)Is(Int x String)s_First
(Real)Is(Real x Char x Int)s_First
(String)Is(ListOf(String)s)s_First
\end{verbatim}
which it turn means that the function \texttt{first} has been defined
for these combinations of types. For more on how conditions, propositions and
ad hoc polymorphism works, see the "Type Logic" section (\ref{subsec:typelogic}).

\item \textit{Grammar}
\begin{grammar}
<condition> ::= <prop-name> `\ ==>\ ' 
\end{grammar}

\end{itemize}

\subsubsection{Type Definitions}
\label{subsubsec:tdefs}

Type definitions are divided into \texttt{tuple_type} definitions and
\texttt{or_type} definitions which are described in the following paragraphs.
\\\\
The grammar of a type definition is:
\begin{grammar}
<type-def> ::= <tuple-type-def> | <or-type-def>
\end{grammar}

\paragraph{Tuple Types}

\begin{itemize}
\item \textit{Definition Examples}

\begin{verbatim}
tuple_type Name
value
  (first_name, last_name) : String^2

tuple_type Date
value
  (day, month, year) : Int^3

tuple_type MathematicianInfo
value
  (name, nationality, date_of_birth) : Name x String x Date

tuple_type TreeOf(A)s
value
  (root, subtrees) : A x ListOf(TreeOf(A)s)s

tuple_type Indexed(T)
value
  (index, val) : Int x T
\end{verbatim}

\item \textit{Usage Examples}

\begin{verbatim}
euler_info : MathematicianInfo
  = (("Leonhard", "Euler"), "Swiss", (15, 4, 1707))

name_to_string : Name => String
  = n => "\nFirst Name: " + n.first_name + "\nLast Name: " + n.last_name

print_name_and_nationality : MathematicianInfo => IO
  = ci => print(ci.name -> name_to_string + "\nNationality: " + ci.nationality)

sum_nodes : TreeOf(Int)s => Int
  = tree => tree.root + tree.subtrees -> apply(sum_nodes)to_all -> sum_list
\end{verbatim}

\item \textit{Description}

A tuple type is equivalent to a product type with a new name  and names for the
fields for convinience. A tuple type generates postfix functions for all of
the fields by using a '.' before the name of the field. For example the
\texttt{MathematicianInfo} type above generates the following functions:
\begin{verbatim}
.name : MathematicianInfo => Name
.nationality : MathematicianInfo => String
.date_of_birth : MathematicianInfo => Date
\end{verbatim}
These functions are named "postfix functions" because they can be appended to
their argument.

\item \textit{Grammar}

\begin{grammar}
<tuple-type-def> ::= ""\\
`tuple_type\ ' <type-name> <nl> \\
`value' <nl> `\ \ ' <paren-comma-sep-ids> `\ :\ '
( <prod-type> | <power-type> )

<type-name> ::= 
[ <params-in-paren> ] <type-id> ( <params-in-paren> [A-Za-z]+ )*
[ <params-in-paren> ]

<params-in-paren> ::= `(' <type-var> ( <comma> <type-var> )* `)'
\end{grammar}

\end{itemize}

\paragraph{Or Types}

\begin{itemize}
\item \textit{Definition Examples}

\begin{verbatim}
or_type Bool
values
  true | false

or_type Possibly(A)
values
  the_value:A | no_value

// needed tuple_type for ListOf(A)s
tuple_type NonEmptyListOf(A)s
value
  (head, tail) : A x ListOf(A)s

or_type ListOf(A)s
values
  non_empty_l:NonEmptyListOf(A)s | empty_l

or_type Error(A)OrResult(B)
values
  error:A | result:B
\end{verbatim}

\item \textit{Usage Examples}

\begin{verbatim}
is_empty : ListOf(A)s => Bool
  = cases
    empty_l => true
    non_empty_l:anything => false

get_head : ListOf(A)s => Possibly(A)
  = cases
    empty_l => no_value
    non_empty_l:list => the_value:list.head

sum_list : ListOf(Int)s => Int
  = cases
    empty_l => 0
    non_empty_l:l => l.head + sum_list(l.tail)

print_err_or_res : Error(A)OrResult(B) => IO
  = cases
    error:e => print("Error occured: " + e -> to_string)
    result:r => print("All good! The result is: " + r -> to_string)
\end{verbatim}

\item \textit{Description}

The values of an \texttt{or_type} are split into cases. Some cases have other
values inside.  The cases which have other values inside are followed by a
semicolon and the type of the internal value. The same syntax can be used for
matching that particular case in a function using the "cases" syntax.  An
\texttt{or_type} definition automatically creates prefix functions for each
case with an internal value (which are simply conversions from the type of the
internal value to the \texttt{or_type}).  For example, for the case
"\texttt{non_empty_l}" of a list, the function "\texttt{non_empty_l}:" is
automatically created from the definition for which we can say:
\begin{verbatim}
non_empty_l:
  : NonEmptyListOf(A)s => ListOf(A)s
\end{verbatim}
Similarly:
\begin{verbatim}
the_value:
  : A => Possibly(A)
\end{verbatim}
These functions are called "prefix functions" because they are prepended to their
argument.
For example:
\begin{verbatim}
non_e_l : NonEmptyListOf(Int)s
  = (1, [2, 3, 4])
>> non_empty_l:non_e_l
  : ListOf(Int)s
  = [1, 2, 3, 4]
\end{verbatim}
These functions can be used like any other function as arguments to other functions.
For example:
\begin{verbatim}
non_empty_ls_to_ls : ListOf(NonEmptyListOf(A)s)s => ListOf(ListOf(A)s)s
  = apply(non_empty_l:)to_each
\end{verbatim}

\item \textit{Grammar}

\begin{grammar}
<or-type-def> ::= ""\\
`or_type\ ' <type-name> <nl> \\
`values' <nl> `\ \ ' <identifier> [ `:' <simple-type> ]
( `\ |\ ' <identifier> [ `:' <simple-type> ] )*
\end{grammar}

\end{itemize}

\subsubsection{Type Nicknames}

\begin{itemize}

\item \textit{Examples}

\begin{verbatim}
type_nickname Ints = ListOf(Int)s
type_nickname IntStringPairs = ListOf(Int x String)s
type_nickname IO = (EmptyVal)FromIO
type_nickname ErrOrRes(A) = Error(String)OrResult(A)
type_nickname Parse(A)FuncT = String => A x String
\end{verbatim}

\item \textit{Description} \\\\
Type nicknames are used to abbreviate or give a more descriptive name to a type.
They start with the keyword "\texttt{type_nickname}", followed by the nickname, 
then an equal sign and they end with the type to be nicknamed.

\item \textit{Grammar}

\begin{grammar}
<t-nickname> ::= `type_nickname\ ' <type-name> `\ =\ ' <simple-type>
\end{grammar} 

\end{itemize}

\subsection{Type Logic}
\label{subsec:typelogic}

Type logic is the mechanism for ad hoc polymorphism in lcases. The central
notion of \textbf{type logic} is the \textbf{type proposition}. A type
proposition is a proposition that has types as parameters and is true or false
for particular type arguments.
\\\\
Type propositions can either be defined or proven (for certain type arguments).
Therefore, the following constructs exist and accomplish the aforementioned
respectively: \textbf{type proposition definitions} and \textbf{type theorems}.
These constructs are described in detail in the following sections. From this
point onwards the "type" part will be omitted, i.e. propositions are always
type propositions and theorems are always type theorems. 

\subsubsection{Proposition Definitions}

Proposition definitions are split into definitions of \textbf{atomic
propositions} and definitions of \textbf{renaming propositions} which are
described in the following paragraphs.

\paragraph{Atomic Propositions}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
type_proposition (A)Is(B)s_First
value
  first : B => A

type_proposition (T)Has_String_Repr
value
  to_string : T => String

type_proposition (T)Has_A_Wrapper
value
  wrapper : A => T(A)

type_proposition (T)Has_Internal_App
value
  apply()internally : (A => B) x T(A) => T(B)
\end{verbatim}
The examples above define the following (ad hoc) polymorphic functions which
have the respective (conditional) types:
\begin{verbatim}
first : (A)Is(B)s_First ==> B => A

to_string : (T)Has_String_Represantion ==> T => String

wrapper : (T)Has_A_Wrapper ==> A => T(A)

apply()internally : (T)Has_Internal_App ==> (A => B) x T(A) => T(B)
\end{verbatim}

\item \textit{Description}

An atomic proposition definition defines simultaneously the \textbf{atomic
proposition} itself and a \textbf{polymorphic value} (usually, but not
necessarily, a function), by definining the form of the type of the value given
the type parameters of the proposition. The proposition is true or false when
the type parameters are substituted by specific type arguments depending on
whether the implementation of the value has been defined for these type
arguments. The aforementioned truthvalue determines whether the value is used
correctly inside the program and therefore whether the program will typecheck.
In order to add more types for which the function works, i.e.  define the
function for these types, i.e. make the proposition true for these types, one
must prove a theorem. The specifics of theorems are described in the next
section. For now, we'll show the example for everything mentioned in this
paragraph for the proposition \texttt{(A)Is(B)s_First}:

\begin{itemize}
\item Proposition Definition:

\begin{verbatim}
type_proposition (A)Is(B)s_First
value
  first : B => A
\end{verbatim}

\item Function defined and its type:

\begin{verbatim}
first : (A)Is(B)s_First ==> B => A
\end{verbatim}

\item Theorems for specific types:

\begin{verbatim}
type_theorem (A)Is(A x B)s_First
proof
  first = .1st

type_theorem (A)Is(ListOf(A)s)s_First
proof
  first =
    cases
      empty_l => show_err("Tried to take the first element of an empty_l list")
      non_empty_l:l => l.head
\end{verbatim}

\item Usage of the function
\begin{verbatim}
pair, list
  : Int x String, ListOf(String)s
  = (42, "The answer to everything"), ["Hi!", "Hello", Heeey"]

>> pair -> first
  : Int
  = 42
>> list -> first
  : String
  = "Hi!"
\end{verbatim}
\end{itemize}

An atomic proposition definition begins with the keyword
\texttt{type_proposition} followed by the name of the proposition (including
the type parameters) in the first line. The second line is the keyword
\texttt{value}. The third line is indented once and has the identifier and the
type expression of the value seperated by the string " \texttt{:} ".

\end{itemize}

\paragraph{Renaming Propositions}

\begin{itemize}
\item \textit{Examples}
\begin{verbatim}
type_proposition (T)Has_Equality
equivalent
  (T)And(T)Can_Be_Equal

type_proposition (A)And(B)Are_Comparable
equivalent
  (A)Can_Be_Less_Than(B), (A)And(B)Can_Be_Equal, (A)Can_Be_Greater_Than(B)

type_proposition (T)Has_Comparison
equivalent
  (T)And(T)Are_Comparable
\end{verbatim}

\item \textit{Description}

A renaming proposition definition is used to abbreviate one or the conjunction
of many propositions (i.e. AND of all of them) into one new proposition.
\\\\
A renaming proposition definition begins with the keyword
\texttt{type_proposition} followed by the name of the proposition (including
the type parameters) in the first line. The second line is the keyword
\texttt{equivalent}. The third line is indented once and has either one
proposition or (if it is a conjunction) many propositions  seperated by commas
(where the commas essentially mean "and").

\end{itemize}

\paragraph{Grammar for Proposition Definitions}

\begin{grammar}
<type-prop-def> ::= <atom-prop-def> | <renaming-prop-def>
\\

<atom-prop-def> ::=
<prop-name-line> <nl> `value' <nl> `\ \ ' <identifier> `\ :\ ' <simple-type>

<renaming-prop-def> ::=
<prop-name-line> <nl> `equivalent' <nl> `\ \ ' <prop-name> ( <comma> <prop-name> )*

<prop-name-line> ::= `type_proposition\ ' <prop-name>

<prop-name> ::=  ""\\""
[A-Z] ( <name-part> <params-in-paren> )+ [ <name-part> ]
\alt " "( <params-in-paren> <name-part> )+ [ <params-in-paren> ]

<name-part> ::= ( [A-Za-z] | `_'[A-Z] )+
\end{grammar} 

\subsubsection{Theorems}
\label{subsubsec:ttheo}

Theorems are split into theorems of \textbf{atomic propositions} and
theorems of \textbf{implication propositions} which are described in the
following paragraphs.

\paragraph{Atomic Propositions}

\begin{itemize}
\item \textit{Examples}

\begin{verbatim}
type_theorem (Possibly())Has_A_Wrapper
proof
  wrapper = the_value:

type_theorem (ListOf()s)Has_A_Wrapper
proof
  wrapper = x => [x]

type_theorem (Possibly())Has_Internal_App
proof
  apply()internally =
    (f, cases)
      no_value => no_value
      the_value:x => the_value:f(x)

type_theorem (ListOf()s)Has_Internal_App
proof
  apply()internally =
    (f, cases)
      empty_l => empty_l
      non_empty_l:l => non_empty_l:(f(l.head), l.tail -> apply(f)internally)
\end{verbatim}

\item \textit{Usage}

\begin{verbatim} 
a, b : all Possibly(Int)
  = wrapper(1), no_value

l1, l2, l3 : all ListOf(Int)s
  = wrapper(1), empty_l, [1, 2, 3]

>> a
  : Possibly(Int)
  = the_value:1
>> b
  : Possibly(Int)
  = no_value
>> l1
  : ListOf(Int)s
  = [1]
>> l2
  : ListOf(Int)s
  = []

>> a -> apply(x => x + 1)internally
  : Possibly(Int)
  = the_value:2
>> b -> apply(x => x + 1)internally
  : Possibly(Int)
  = no_value
>> l1 -> apply(x => x + 1)internally
  : ListOf(Int)s
  = [2]
>> l2 -> apply(x => x + 1)internally
  : ListOf(Int)s
  = []
>> l3 -> apply(x => x + 1)internally
  : ListOf(Int)s
  = [2, 3, 4]
\end{verbatim}

\item \textit{Description}

A theorem of an atomic proposition proves the proposition for
specific type arguments, by implementing the value associated to the
proposition for these type arguments. Therefore, the value associated with the
proposition can be used with all the combinations of type arguments for which
the proposition is true, i.e. the combinations of type arguments for which
the value has been implemented.
\\\\
A proof of a theorem of an atomic proposition is correct when the
implementation of the value associated with the proposition follows the form of
the type given to the value by the definition of the proposition, i.e. the only
difference between the type of the value in the theorem and the type of the
value in the definition is that the type parameters of the proposition are
substituted by the type arguments of the theorem.
\\\\
A theorem of an atomic proposition begins with the keyword
\texttt{type_theorem} followed by the name of the proposition with the type
parameters substituted by the specific types for which the proposition will be
proven. The second line is the keyword \texttt{proof}. The third line is
indented once and it is the line in which the proof begins. The proof begins
with the identifier of the value associated with the proposition and is followed
by the string " \texttt{=} " and the value expression which implements the value.

\end{itemize}

\paragraph{Implication Propositions}

\begin{itemize}
\item \textit{Examples}

\begin{verbatim}
type_theorem (A)And(B)Can_Be_Equal => (A)And(B)Can_Be_Unequal
proof
  a \= b = not(a = b)

type_theorem (A)Can_Be_Greater_Than(B) => (A)Can_Be_Le_Or_Eq_To(B)
proof
  a <= b = not(a > b)

type_propositon (A)And(B)Have_Eq_And_Gr
equivalent
  (A)And(B)Can_Be_Equal, (A)Can_Be_Greater_Than(B)

type_theorem (A)And(B)Have_Eq_And_Gr => (A)Can_Be_Gr_Or_Eq_To(B)
proof
  a >= b = a = b | a > b
\end{verbatim}

\item \textit{Description}

A theorem of an implication proposition is very similar to a theorem of an
atomic proposition in the sense that it also implements a value in the proof.
The difference is that the implementation uses another ad hoc polymorphic value
(or many). Therefore, the implementation does not prove the proposition
associated to the value it implements, because it assumes that the polymorphic
value(s) used in the implementation is(are) already defined. In other words it
proves the following: "if this(these) ad hoc polymorphic value(s) is(are)
defined then we can also define this other one". This can be translated into
the following implication proposition: "if the proposition associated to the
value(s) we are using is true then the proposition associated to the value we
are defining is true", which can be condensed to the notation with the
"\texttt{=>}" arrow used in the examples.
\\\\
The proof of an implication proposition allows the compiler to
automatically create the definition for an ad hoc polymorphic value for a
particular combination of types given the definitions of the ad hoc polymorphic
values used in the implementation for this same combination of types. This
mechanism essentially gives definitions for free, that is in the sense that
when you define a set of ad hoc polymorphic values for a particular set of
types you get for free all the ad hoc polymorphic values that can be defined
using a subset of the defined ones. 
\\\\
A theorem of an implication proposition is grammatically the same as
a theorem of an atomic proposition with the only difference being that an 
implication propostition is comprised by two atomic propositions seperated by
the "\texttt{=>}" arrow.

\end{itemize}

\paragraph{Grammar for Theorems}

\begin{grammar}
<type-theo> ::= ""\\
`type_theorem\ ' <prop-name-sub> [ `\ =>\ ' <prop-name-sub> ] <nl> \\
`proof' <nl> `\ \ ' <identifier> [ <op> <identifier> ] `\ =' <tt-value-expr>

<prop-name-sub> ::=  ""\\""
[A-Z] ( <name-part> <param-subs-in-paren> )+ [ <name-part> ]
\alt " "( <param-subs-in-paren> <name-part> )+ [ <param-subs-in-paren> ]

<param-subs-in-paren> ::= `(' <param-sub> ( <comma> <param-sub> )* `)'

<param-sub> ::= <simple-type> | <type-func>

<type-func> ::=
[ `()' ] <type-id> ( `()' [A-Za-z]+ )+ [ `()' ] | `()' <type-id> [ `()' ] |
<type-id> `()'

<tt-value-expr> ::= `\ ' <line-expr> | <nl> <indent> <big-or-cases-expr>

<big-or-cases-expr> ::=
<big-op-expr> | <big-func-expr> | <cases-func-expr> | <big-tuple> | <big-list>
\end{grammar} 

\subsection{Complete Grammar for Types and Type Logic}

\begin{grammar}
<type> ::= [ <condition> ]  <simple-type> 

<simple-type> ::=
<type-id> | <type-var> | <func-type> | <prod-type> | <power-type> | <type-app>
\\

<type-id> ::= [A-Z] [A-Za-z]+ 

<type-var> ::= [A-Z]
\\

<func-type> ::= <in-or-out-type> `\ =>\ ' <in-or-out-type>

<in-or-out-type> ::=
<type-id> | <type-var> | <prod-type> | <power-type> | <type-app> |
`(' <func-type> `)'
\\

<prod-type> ::= <field-type> ( `\ x\ ' <field-type> )+

<power-type> ::= <field-type> ( `^' <int-greater-than-one> )+

<field-type> ::=
<type-id> | <type-var> | <type-app> | `(' ( <func-type> | <prod-type> ) `)'
\\

<type-app> ::= ""\\""
[ <types-in-paren> ] <type-id-with-args> [ <types-in-paren> ]
\alt " "<types-in-paren> <type-id-or-var> [ <types-in-paren> ]
\alt " "<type-id-or-var> <types-in-paren>

<type-id-with-args> ::= <type-id> ( <types-in-paren> [A-Za-z]+ )+

<type-id-or-var> ::= <type-id> | <type-var>

<types-in-paren> ::= `(' <simple-type> ( <comma> <simple-type> )* `)'
\\

<condition> ::= <prop-name> `\ ==>\ ' 
\\
\\

<type-def> ::= <tuple-type-def> | <or-type-def>
\\

<tuple-type-def> ::= ""\\
`tuple_type\ ' <type-name> <nl> \\
`value' <nl> `\ \ ' <paren-comma-sep-ids> `\ :\ '
( <prod-type> | <power-type> )

<type-name> ::= 
[ <params-in-paren> ] <type-id> ( <params-in-paren> [A-Za-z]+ )*
[ <params-in-paren> ]

<params-in-paren> ::= `(' <type-var> ( <comma> <type-var> )* `)'
\\

<or-type-def> ::= ""\\
`or_type\ ' <type-name> <nl> \\
`values' <nl> `\ \ ' <identifier> [ `:' <simple-type> ]
( `\ |\ ' <identifier> [ `:' <simple-type> ] )*
\\

<t-nickname> ::= `type_nickname\ ' <type-name> `\ =\ ' <simple-type>
\\\\

<type-prop-def> ::= <atom-prop-def> | <renaming-prop-def>
\\

<atom-prop-def> ::=
<prop-name-line> <nl> `value' <nl> `\ \ ' <identifier> `\ :\ ' <simple-type>

<renaming-prop-def> ::=
<prop-name-line> <nl> `equivalent' <nl> `\ \ ' <prop-name> ( <comma> <prop-name> )*

<prop-name-line> ::= `type_proposition\ ' <prop-name>

<prop-name> ::=  ""\\""
[A-Z] ( <name-part> <params-in-paren> )+ [ <name-part> ]
\alt " "( <params-in-paren> <name-part> )+ [ <params-in-paren> ]

<name-part> ::= ( [A-Za-z] | `_'[A-Z] )+
\\

<type-theo> ::= ""\\
`type_theorem\ ' <prop-name-sub> [ `\ =>\ ' <prop-name-sub> ] <nl> \\
`proof' <nl> `\ \ ' <identifier> [ <op> <identifier> ] `\ =' <tt-value-expr>

<prop-name-sub> ::=  ""\\""
[A-Z] ( <name-part> <param-subs-in-paren> )+ [ <name-part> ]
\alt " "( <param-subs-in-paren> <name-part> )+ [ <param-subs-in-paren> ]

<param-subs-in-paren> ::= `(' <param-sub> ( <comma> <param-sub> )* `)'

<param-sub> ::= <simple-type> | <type-func>

<type-func> ::=
[ `()' ] <type-id> ( `()' [A-Za-z]+ )+ [ `()' ] | `()' <type-id> [ `()' ] |
<type-id> `()'

<tt-value-expr> ::= `\ ' <line-expr> | <nl> <indent> <big-or-cases-expr>

<big-or-cases-expr> ::=
<big-op-expr> | <big-func-expr> | <cases-func-expr> | <big-tuple> | <big-list>
\end{grammar}

\section{Language Description: Predefined}

\subsection{Values}

\begin{itemize}

\item Constants: \texttt{undefined, pi}

\item Functions
  \begin{itemize}

  \item Miscellaneous: \texttt{not, id, show_error}

  \item Numerical
    \begin{itemize}
    \item Miscellaneous: \texttt{sqrt, abs, max, min}
    \item Trigonometric: \texttt{sin, cos, tan, asin, acos, atan}
    \item Division related: \texttt{div, mod, gcd, lcm, even, odd}
    \item Rounding: \texttt{truncate, round, floor, ceiling}
    \item e and log: \texttt{exp, ln, log}
    \end{itemize}

  \item List:\\
    \texttt{length, is_in, apply()to_all, filter_with, take()from, leave()from,
    zip, unzip,\\ zip_with}

  \item IO
    \begin{itemize}
    \item Input: \texttt{get_char, get_line, get_input, read_file}
    \item Output: \texttt{print, print_string, print_line, write_file}
    \end{itemize}

  \item Ad Hoc Polymorphic:\\
  \texttt{first, second, third, fourth, fifth, wrap, to_string, from_string,
  apply()internally, \\wrapd_apply()intern}

  \end{itemize}
\end{itemize}

\subsection{Types}

\begin{itemize}
\item Basic: \texttt{Int, Real, Char, String}\ \ \ TODO? array: eg 10 * Int?
\item Or Types: \texttt{EmptyVal, Bool, Possibly(), ListOf()s, Result()OrError()}
\item Tuple Types: \texttt{NonEmptyListOf()s}
\item Type Nicknames: \texttt{IO}
\end{itemize}

\subsection{Type Propositions}

\begin{itemize}

\item Operator Propositions:

  \begin{itemize}
  \item \texttt{(A)To_The(B)Has_Type(C)}
  \item \texttt{(A)And(B)Multiply_To(C)}
  \item \texttt{(A)Divided_By(B)Has_Type(C)}
  \item \texttt{(A)And(B)Add_To(C)}
  \item \texttt{(A)Minus(B)Has_Type(C)}
  \item \texttt{(A)And(B)Can_Be_Equal}
  \item \texttt{(A)And(B)Can_Be_Unequal}
  \item \texttt{(A)Can_Be_Gr_Or_Eq_To(B)}
  \item \texttt{(A)Can_Be_Le_Or_Eq_To(B)}
  \item \texttt{(A)Can_Be_Greater_Than(B)}
  \item \texttt{(A)Can_Be_Less_Than(B)}
  \item \texttt{(T)Has_Use}
  \item \texttt{(T)Has_Then}
  \end{itemize}

\item Function Propositions:

  \begin{itemize}
  \item \texttt{(A)Is(B)s_First}
  \item \texttt{(A)Is(B)s_Second}
  \item \texttt{(A)Is(B)s_Third}
  \item \texttt{(A)Is(B)s_Fourth}
  \item \texttt{(A)Is(B)s_Fifth}
  \item \texttt{(T)Has_A_Wrapper}
  \item \texttt{(T)Has_String_Repr}
  \item \texttt{(T)Can_Be_Parsed}
  \item \texttt{(T)Has_Internal_App}
  \item \texttt{(T)Has_Wrapd_Intern_App}
  \end{itemize}

\item Renaming Propositions:

  \begin{itemize}
  \item \texttt{(T)Has_Exponentiation}
  \item \texttt{(T)Has_Multiplication}
  \item \texttt{(T)Has_Division}
  \item \texttt{(T)Has_Addition}
  \item \texttt{(T)Has_Subtraction}
  \item \texttt{(T)Has_Equality}
  \item \texttt{(T)Has_Non_Equality}
  \item \texttt{(T)Has_Greater_Or_Equal}
  \item \texttt{(T)Has_Less_Or_Equal}
  \item \texttt{(T)Has_Greater}
  \item \texttt{(T)Has_Less}
  \end{itemize}

\item Theorems:

  \begin{itemize}
  \item \texttt{(A)Is(A x B)s_First}
  \item \texttt{(A)Is(A x B x C)s_First}
  \item \texttt{(A)Is(A x B x C x D)s_First}
  \item \texttt{(A)Is(A x B x C x D x E)s_First}
  \item \texttt{(A)Is(ListOf(A)s)s_First}
  \item \texttt{(B)Is(A x B)s_Second}
  \item \texttt{(B)Is(A x B x C)s_Second}
  \item \texttt{(B)Is(A x B x C x D)s_Second}
  \item \texttt{(B)Is(A x B x C x D x E)s_Second}
  \item \texttt{(A)Is(ListOf(A)s)s_Second}
  \item \texttt{(C)Is(A x B x C)s_Third}
  \item \texttt{(C)Is(A x B x C x D)s_Third}
  \item \texttt{(C)Is(A x B x C x D x E)s_Third}
  \item \texttt{(A)Is(ListOf(A)s)s_Third}
  \item \texttt{(D)Is(A x B x C x D)s_Fourth}
  \item \texttt{(D)Is(A x B x C x D x E)s_Fourth}
  \item \texttt{(A)Is(ListOf(A)s)s_Fourth}
  \item \texttt{(E)Is(A x B x C x D x E)s_Fifth}
  \item \texttt{(A)Is(ListOf(A)s)s_Fifth}
  \item \texttt{TODO wrapper}
  \item \texttt{(Int)Has_String_Repr}
  \item \texttt{(Char)Has_String_Repr}
  \item \texttt{(Real)Has_String_Repr}
  \item \texttt{(A)Has_String_Repr => (ListOf(A)s)Has_String_Repr}
  \item \texttt{TODO apply()internally}
  \item \texttt{TODO wrapd_apply()intern}
  \item \texttt{TODO ;>}
  \item \texttt{TODO ;}
  \end{itemize}

\end{itemize}

\section{Parser implementation}

The parser was implemented using the parsec library.

\subsection{AST Types}

\subsection{Parsers}

\section{Translation to \H}

\section{Running Examples}

\section{Conclusion}

\end{document}
