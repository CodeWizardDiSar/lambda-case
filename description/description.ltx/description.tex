\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{syntax}
\usepackage[left=2cm,right=2cm,top=2cm]{geometry}

\date{}
\author{
  Dimitris Saridakis
}

\def\imgs{../Images}
\def\H{Haskell}
%\newcommand\_[_]{_}

\begin{document}

\title{
\textbf{Lambda Cases}
}
\maketitle

\section{Introduction}

\H\ is a delightful language. Yet, for some reason, it doesn't seem to have it's 
rightful place in terms of popularity. Why is it so? Is it inherently hard to learn
and therefore only the brave enough students and corporations dare to use it, or
could it be that the syntax is perplexing to the amateur eye? It is my belief that 
with some syntax changes that give a greater familiarity to the new user, there
would be no language more compelling than (the new) \H. In an attempt to achieve
that familiarity, I present some new syntax for certain patterns of which,
some is closer to the imperative/OOP style (to attract more already experienced
programmers from these languages), some is closer to mathematics (in which most 
programmers should be experienced) and some is closer to natural language
(in which we are all already experienced). Ofcourse, I could not rewrite \H\
from scratch by my self, so I will try to keep the language as small and to the 
point as possible for now, as well as use as much as I can from \H\ itself, as 
the new language (Lambda Cases) is compiled to \H.

\section{Language Description}

\subsection{Values}

\subsubsection{Value Expressions}

\paragraph{Operator Expressions}\mbox{} \\\\
Function Application has an operator: 
\begin{verbatim}
==>: A -> (A -> B) -> B
<==: (A -> B) -> A -> B
\end{verbatim}
The usual operators:
\begin{verbatim}
+ - = <= >= 
\end{verbatim}

\paragraph{Abstractions}

\begin{verbatim}
a -> body
(x, y, z) -> body
use_fields -> body
cases -> body
\end{verbatim}

\paragraph{Specific Abstractions}

\subsubsection{Value Definitions}

\paragraph{Examples}

\begin{verbatim}
foo: Int
  = 42

val1, val2, val3: Int, Bool, Char
  = 42, true, 'a'

int1, int2, int3: all Int
  = 1, 2, 3

succ: Int -> Int
  = x -> x + 1

f: (Int, Int, Int) -> Int
  = (a, b, c) -> a + b * c
\end{verbatim}

\paragraph{Description}\mbox{} \\\\
To define a new value you give it a name, a type and an expression. It is possible
to group value definitions by seperating the names, the types and the expressions
with commas. It is also possible to use the keyword "all" to give the same type
to all the values.

\paragraph{Examples in \H}

\begin{verbatim}
foo :: Int
foo = 42

val1 :: Int
val1 = 42
val2 :: Bool
val2 = true
val3 :: Char
val3 = 'a'

int1 :: Int
int1 = 1
int2 :: Int
int2 = 2
int3 :: Int
int3 = 3

succ :: Int -> Int
succ = \x -> x + 1

f :: Int -> Int -> Int -> Int
f = \a b c -> a + b * c
\end{verbatim}

\subsection{Types}

\subsubsection{Or Types}

\paragraph{Examples}

\begin{verbatim}
or_type Bool
values true | false

or_type Possibly<==A
values wrapper<==(value: A) | nothing

or_type ListOf(A)s
values non_empty<==(value: NonEmptyListOf(A)s) | empty

tuple_type NonEmptyListOf(A)s
value (head: T, tail: ListOf(A)s)

is_empty: ListOf(A)s -> Bool
  = cases -> 
    empty -> true
    non_empty -> false

get_head: ListOf(A)s -> Possibly<==A
  = cases -> 
    empty -> nothing
    non_empty -> head==>wrapper
\end{verbatim}

\paragraph{Description}\mbox{} \\\\
Values of an Or Type are one of many cases that possibly have values of other types
inside. Or Types together with Int and Char are the only types on which the "cases"
syntax can be used.

\paragraph{Examples in \H}

\begin{verbatim}
{-# language LambdaCase #-}

data Bool =
  Ctrue | Cfalse

data Possibly a =
  Cwrapper a | Cnothing

data ListOf_s a =
  Cnon_empty (NonEmptyListOf_s a) | Cempty

data NonEmptyListOf_s a =
  CNonEmptyListOf_s a (ListOf_s a)

is_empty :: ListOf_s a -> Bool
is_empty = \case
  Cempty -> Ctrue
  Cnon_empty (CNonEmptyListOf_s head tail) -> Cfalse

get_head :: ListOf_s a -> Possibly a
get_head = \case
  Cempty -> Cnothing
  Cnon_empty (CNonEmptyListOf_s head tail) -> Cwrapper head
\end{verbatim}

\paragraph{Autogenerated Functions}

Or Types the following have automatically generated functions:

\begin{verbatim}
is_case:
\end{verbatim}

\subsubsection{Tuple Types}

\paragraph{Examples}

\begin{verbatim}
tuple_type ClientInfo
value (name: String, age: Int, nationality: String)

tuple_type ExprT==>WithPosition
value (expr: ExprT, line: Int, column: Int)

tuple_type (FirstT, SecondT)==>Pair
value (first: FirstT, second: SecondT)
\end{verbatim}

\paragraph{Description}\mbox{} \\\\
Tuple types group many values into a single value.

\paragraph{Examples in \H}

\begin{verbatim}
data ClientInfo =
  ClientInfoC String Int String

data WithPosition a = 
  WithPositionC a Int Int

data Pair a b = 
  PairC a b
\end{verbatim}

\paragraph{Autogenerated Functions}

\subsection{Type Logic}

\paragraph{Type Predicate}

\paragraph{Type Theorem}

\subsection{Grammar}
\subsubsection{Tokens}

\paragraph{Keywords}

\begin{verbatim}
cases use_fields tuple_type or_type
\end{verbatim}

\paragraph{Value names}

\begin{grammar}
<value-name> ::= 
<lower-case-letter> ( <lower-case-letter> | `_' )*
\end{grammar}

\paragraph{Type names}

\begin{grammar}
<type-name> ::= 
<upper-case-letter> ( <upper-case-letter> | <lower-case-letter> )*
\end{grammar}



\subsubsection{Core Grammar}

\setlength{\grammarparsep}{20pt}
\setlength{\grammarindent}{12em}

\paragraph{Program}
\hspace{1cm}\\
\begin{grammar}

<program> ::= (<value-defs> | <type-def>)+

<value-defs> ::=
<value-names> `:\ ' (<types> | `all' <type>) `\\n\ \ =' <value-exprs>

<value-names> ::= <value-name> ( `,\ ' <value-name> )*  

<types> ::= <type> ( `,\ ' <type> )*  

<value-exprs> ::= <value-expr> ( `,\ ' <value-expr> )*  

\end{grammar}
\hspace{1cm}\\

\paragraph{Types}

\hspace{1cm}\\
\begin{grammar}

<type> ::= <func-type> | <prod-type> | <type-app>

<func-type> ::= <input-types-expr> `\ ->\ ' <output-type>

<prod-type> ::= <prod-sub-type> ( `\ x\ ' <prod-sub-type> )+

<type-app> ::= [ <t-inputs> `==>' ] <type-name> [ `<==' <t-inputs> ]
 
<input-types-expr> ::= <many-ts-in-paren> | <one-type>

<output-type> ::= <prod-type> | <type-app>

<prod-sub-type> ::= `(' ( <func-type> | <prod-type> ) `)' | <type-app>

<one-type> ::= `(' <func-type> `)' | <prod-type> | <type-app>

<t-inputs> ::= <many-ts-in-paren> | `(' <type> `)' | <type-name>

<many-ts-in-paren> ::=  `(' <type> (`, ' <type>)+ `)'

\end{grammar}


\hspace{1cm}\\

\paragraph{Value Expressions}

\hspace{1cm}\\
\begin{grammar}

<value-expr> ::= [ <input-expr> ] <cases-or-where> | <op-expr>

<cases-or-where> ::= <cases-expr> | <where-expr>

<where-expr> ::=
`let' <spicy-nl> (<value-defs> <spicy-nls>)+ `in' <value-expr> <spicy-nl>

<cases-expr> ::= `cases' ( <case> )+ [ <default-case> ]

\end{grammar}

\section{Parser implimentation}
\section{Translation to \H}
\section{Running examples}
\section{Conclusion}

\hspace{1cm}\\
%\newpage

%EDE
%\paragraph{Examples}
%
%\begin{verbatim}
%\end{verbatim}
%
%\paragraph{Description}\mbox{} \\\\
%desc
%
%\paragraph{Examples in \H}
%
%\begin{verbatim}
%\end{verbatim}

%  \includegraphics[width=10cm, height=8cm]{../Images/image.png}

\end{document}
